---
sidebar_position: 6
---

# 🛰️ 安装插件扩展模块[ex]
## 📌 函数: HD扩展_安装插件1
### 描述
```
第一种通讯安装插件方式(安装插件再打开进程)如果使用HD多线程模块强烈建议在登录回调中使用
```
### 原型
```cpp
__int64 __stdcall HDEX_InstallPlugin1(__int32 winIndex,char* app,int appType,int injectType,int memeType,int gameType,BOOL bAccept,__int64 openFun,__int64 checkFun=NULL,int timeOut=30000);
```
### 参数
```
__int32 winIndex - 窗口序号
char* app - 进程名
int appType - 进程类型32/64
int injectType - 注入类型012
int memeType - 内存模式012
int gameType - 游戏类型一般为0就行
bool bAccept - 是否开启接受线程
__int64 openFun - 打开回调回调类型
__int64 checkFun - 检查回调回调类型
int timeOut - 超时时间
```
### 返回值
```
查看返回值表
```
### 注意事项
```
可以参考表安装插件接口类型表
1.支持重连,重连的前提是不能被HCEnv_UnLoad卸载
回调解析:
打开回调openFun:可以参考表安装插件接口类型表
typedef__int64 (__stdcall* INSTALLPLUGint YPE)(int windowsIndex);
参数:windowsIndex:当前指定序号
说明:1.对于第一种方式打开回调不能为NULL,内部先安装插件再触发回调打开进程(在打开回调中可以手动或者自动打开进程1.如果是手动直接返回1就行或错误值表示中断操作2.如果是自动返回对应的PID或错误值表示中断操作)2.其他二种方式打开回调可以为NULL,表示进程已经打开了,不需要在回调中打开,此时使用指定的PID或者窗口句柄来安装插件,具体是PID还是句柄请查看安装插件接口类型表3.返回值根据当前的安装插件方式不同有不同的含义:（具体请看安装插件接口类型表和覆盖策略）
3.1方式二是通过PID安装插件那么返回值应该为打开进程的PID,并把传递的PID参数给覆盖了(请看PID覆盖策略),可以返回小于等于0的错误值或者不存在的PID,从而中断安装插件退出,不做相应的安装插件流程(初始化序号-获取PID-加载环境-等待20-继续-等待120),并把打开回调返回值当作安装插件返回值返回。
3.1.1PID覆盖策略
\n1.如果指定的参数PID有效大于0并存在同时打开回调返回的PID有效大于0并存在就用打开回调返回的PID覆盖指定参数的PID\n2.如果指定的参数PID有效大于0并存在同时打开回调返回的PID无效小于等于0不存在就用指定参数的PID\n3.如果指定的参数PID无效小于等于0不存在同时打开回调返回的PID无效小于等于0不存在就直接返回错误\n4.如果指定的参数PID无效小于等于0不存在同时打开回调返回的PID有效大于0并存在就用打开回调返回的PID覆盖指定参数的PID
3.2方式三是通过窗口句柄安装插件那么返回值应该为打开进程的句柄,并把传递的句柄参数给覆盖了(请看窗口句柄覆盖策略),可以返回小于等于0的错误值或者窗口句柄无效,从而中断安装插件退出,不做相应的安装插件流程(初始化序号-获取PID-加载环境-等待20-继续-等待120),并把打开回调返回值当作安装插件返回值返回。
3.2.1窗口句柄覆盖策略
\n1.如果指定参数的窗口句柄有效同时打开回调返回的的句柄有效就用打开回调返回的句柄覆盖指定参数的句柄\n2.如果指定参数的窗口句柄有效同时打开回调返回的的句柄无效就用指定参数的句柄\n3.如果指定参数的窗口句柄无效同时打开回调返回的的句柄无效就直接返回错误\n4.如果指定参数的窗口句柄无效同时打开回调返回的的句柄有效就用打开回调返回的句柄覆盖指定参数的句柄
检查回调checkFun:
typedef__int64 (__stdcall* CHECKINSTALLPLUGint YPE)(int windowsIndex,int preWindowsIndex,int prePid,int error);
参数:windowsIndex:当前指定序号preWindowsIndex:之前绑定的序号或者错误值(小于0)--来源HCInject_GetPreWinIndex返回prePid:之前绑定的序号对应的PID--来源HCInject_GetPid返回error:提示值
error==RET_重连窗口(5)----->返回值含义:(1重连直接进行加载环境0新窗口)
error== RET_检查PID存在(8)----->触发条件:内部检查是PID不存在触发,这种情况一般是隐藏PID导致的或者真实不存在 返回值含义 :(大于0表示开发者认为prepid参数指定的PID是存在的)  我们一般返回-1或者0就行,除非有特殊情况,比如隐藏了进程导致内部遍历系统拿不到PID这个时候会发送RET_检查PID存在(8)告知开发者来做处理 
error==RET_重连窗口序号不一致(6)----->返回值含义:(1重连并使用之前绑定的序号进行加载环境   0新窗口(需要用户在回调中把之前PID给关闭)) 

error== RET_检查PID存在(8)----->触发条件:内部检查是PID不存在触发,这种情况一般是隐藏PID导致的或者真实不存在 返回值含义 :(大于0表示开发者认为prepid参数指定的PID是存在的)  我们一般返回-1或者0就行,除非有特殊情况,比如隐藏了进程导致内部遍历系统拿不到PID这个时候会发送RET_检查PID存在(8)告知开发者来做处理 

其他情况可以返回小于0的自定义值:表示直接中断安装插件流程,并返回对应的值(这个值只要小于0即可,可以作为自定义值)
说明:
1.如果指定的检查回调为NULL,当内部检查到是重连窗口的时候
2.如果发现序号不一致就会直接返回(ERROR_当前进程插件序号不一致-1216)
3.如果序号一致就直接加载环境并实现重连
几个核心的点归纳总结出来其实就能规避掉很多坑了比如1.没安装过插件的都不算重连窗口全部当新窗口处理会触发打开回调2.安装过插件的不管是卸载了环境还是崩溃或重启中控都算重连窗口不会触发打开回调会触发检查回调

```
### HD扩展_安装插件1 - 基础示例
```python
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```
### HD扩展_安装插件1 - 进阶用法
```python
# Python 示例2
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```
### HD扩展_安装插件1 - 高级应用
```python
# Python 示例3 高级用法
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```

---
## 📌 函数: HD扩展_安装插件2
### 描述
```
第二种通讯安装插件方式(打开进程然后安装插件),通过pid如果使用HD多线程模块强烈建议在登录回调中使用
```
### 原型
```cpp
__int64 __stdcall HDEX_InstallPlugin2(__int32 winIndex,int funType,int pid,int appType,int gameType,BOOL bAccept,__int64 openFun=NULL,__int64 checkFun=NULL,int timeOut=30000);
```
### 参数
```
__int32 winIndex - 窗口序号
int funType - 内部安装插件接口类型查看安装插件接口类型表支持246
int pid - 指定PID可以为0,但是必须指定打开回调,打开回调返回PID
int appType - 进程类型32/64
int gameType - 游戏类型一般为0就行
bool bAccept - 是否开启接受线程
__int64 openFun - 打开回调回调类型
__int64 checkFun - 检查回调回调类型
int timeOut - 超时时间
```
### 返回值
```
查看返回值表
```
### 注意事项
```
可以参考表安装插件接口类型表
1.支持重连,重连的前提是不能被HCEnv_UnLoad卸载
回调解析:
打开回调openFun
typedef__int64 (__stdcall* INSTALLPLUGint YPE)(int windowsIndex);
参数:windowsIndex:当前指定序号
说明:1.对于第一种方式打开回调不能为NULL,内部先安装插件再触发回调打开进程(在打开回调中可以手动或者自动打开进程1.如果是手动直接返回1就行或错误值表示中断操作2.如果是自动返回对应的PID或错误值表示中断操作)2.其他二种方式打开回调可以为NULL,表示进程已经打开了,不需要在回调中打开,此时使用指定的PID或者窗口句柄来安装插件,具体是PID还是句柄请查看安装插件接口类型表3.返回值根据当前的安装插件方式不同有不同的含义:（具体请看安装插件接口类型表和覆盖策略）
3.1方式二是通过PID安装插件那么返回值应该为打开进程的PID,并把传递的PID参数给覆盖了(请看PID覆盖策略),可以返回小于等于0的错误值或者不存在的PID,从而中断安装插件退出,不做相应的安装插件流程(初始化序号-获取PID-加载环境-等待20-继续-等待120),并把打开回调返回值当作安装插件返回值返回。
3.1.1PID覆盖策略
\n1.如果指定的参数PID有效大于0并存在同时打开回调返回的PID有效大于0并存在就用打开回调返回的PID覆盖指定参数的PID\n2.如果指定的参数PID有效大于0并存在同时打开回调返回的PID无效小于等于0不存在就用指定参数的PID\n3.如果指定的参数PID无效小于等于0不存在同时打开回调返回的PID无效小于等于0不存在就直接返回错误\n4.如果指定的参数PID无效小于等于0不存在同时打开回调返回的PID有效大于0并存在就用打开回调返回的PID覆盖指定参数的PID
3.2方式三是通过窗口句柄安装插件那么返回值应该为打开进程的句柄,并把传递的句柄参数给覆盖了(请看窗口句柄覆盖策略),可以返回小于等于0的错误值或者窗口句柄无效,从而中断安装插件退出,不做相应的安装插件流程(初始化序号-获取PID-加载环境-等待20-继续-等待120),并把打开回调返回值当作安装插件返回值返回。
3.2.1窗口句柄覆盖策略
\n1.如果指定参数的窗口句柄有效同时打开回调返回的的句柄有效就用打开回调返回的句柄覆盖指定参数的句柄\n2.如果指定参数的窗口句柄有效同时打开回调返回的的句柄无效就用指定参数的句柄\n3.如果指定参数的窗口句柄无效同时打开回调返回的的句柄无效就直接返回错误\n4.如果指定参数的窗口句柄无效同时打开回调返回的的句柄有效就用打开回调返回的句柄覆盖指定参数的句柄
检查回调checkFun:
typedef__int64 (__stdcall* CHECKINSTALLPLUGint YPE)(int windowsIndex,int preWindowsIndex,int prePid,int error);
参数:windowsIndex:当前指定序号preWindowsIndex:之前绑定的序号或者错误值(小于0)--来源HCInject_GetPreWinIndex返回prePid:之前绑定的序号对应的PID--来源HCInject_GetPid返回error:提示值
error==RET_重连窗口(5)----->返回值含义:(1重连直接进行加载环境0新窗口)
error== RET_检查PID存在(8)----->触发条件:内部检查是PID不存在触发,这种情况一般是隐藏PID导致的或者真实不存在 返回值含义 :(大于0表示开发者认为prepid参数指定的PID是存在的)  我们一般返回-1或者0就行,除非有特殊情况,比如隐藏了进程导致内部遍历系统拿不到PID这个时候会发送RET_检查PID存在(8)告知开发者来做处理 
error==RET_重连窗口序号不一致(6)----->返回值含义:(1重连并使用之前绑定的序号进行加载环境0新窗口(需要用户在回调中把之前PID给关闭))
说明:
1.如果指定的检查回调为NULL,当内部检查到是重连窗口的时候
2.如果发现序号不一致就会直接返回(ERROR_当前进程插件序号不一致-1216)
3.如果序号一致就直接加载环境并实现重连
几个核心的点归纳总结出来其实就能规避掉很多坑了比如1.没安装过插件的都不算重连窗口全部当新窗口处理会触发打开回调2.安装过插件的不管是卸载了环境还是崩溃了中控都算重连窗口不会触发打开回调
```
### HD扩展_安装插件2 - 基础示例
```python
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```
### HD扩展_安装插件2 - 进阶用法
```python
# Python 示例2
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```
### HD扩展_安装插件2 - 高级应用
```python
# Python 示例3 高级用法
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```

---
## 📌 函数: HD扩展_安装插件3
### 描述
```
第三种通讯安装插件方式(打开进程然后安装插件),通过窗口句柄如果使用HD多线程模块强烈建议在登录回调中使用
```
### 原型
```cpp
__int64 __stdcall HDEX_InstallPlugin3(__int32 winIndex,int funType,__int64 hwnd,int appType,int gameType,BOOL bAccept,__int64 openFun=NULL,__int64 checkFun=NULL,int timeOut=30000);
```
### 参数
```
__int32 winIndex - 窗口序号
int funType - 内部安装插件接口类型查看安装插件接口类型表支持357
__int64 hwnd - 指定窗口句柄可以为0,但是必须指定打开回调,打开回调返回窗口句柄
int appType - 进程类型32/64
int gameType - 游戏类型一般为0就行
bool bAccept - 是否开启接受线程
__int64 openFun - 打开回调回调类型
__int64 checkFun - 检查回调回调类型
int timeOut - 超时时间
```
### 返回值
```
查看返回值表
```
### 注意事项
```
可以参考表安装插件接口类型表
1.支持重连,重连的前提是不能被HCEnv_UnLoad卸载
回调解析:
打开回调openFun:可以参考表安装插件接口类型表
typedef__int64 (__stdcall* INSTALLPLUGint YPE)(int windowsIndex);
参数:windowsIndex:当前指定序号
说明:1.对于第一种方式打开回调不能为NULL,内部先安装插件再触发回调打开进程(在打开回调中可以手动或者自动打开进程1.如果是手动直接返回1就行或错误值表示中断操作2.如果是自动返回对应的PID或错误值表示中断操作)2.其他二种方式打开回调可以为NULL,表示进程已经打开了,不需要在回调中打开,此时使用指定的PID或者窗口句柄来安装插件,具体是PID还是句柄请查看安装插件接口类型表3.返回值根据当前的安装插件方式不同有不同的含义:（具体请看安装插件接口类型表和覆盖策略）
3.1方式二是通过PID安装插件那么返回值应该为打开进程的PID,并把传递的PID参数给覆盖了(请看PID覆盖策略),可以返回小于等于0的错误值或者不存在的PID,从而中断安装插件退出,不做相应的安装插件流程(初始化序号-获取PID-加载环境-等待20-继续-等待120),并把打开回调返回值当作安装插件返回值返回。
3.1.1PID覆盖策略
\n1.如果指定的参数PID有效大于0并存在同时打开回调返回的PID有效大于0并存在就用打开回调返回的PID覆盖指定参数的PID\n2.如果指定的参数PID有效大于0并存在同时打开回调返回的PID无效小于等于0不存在就用指定参数的PID\n3.如果指定的参数PID无效小于等于0不存在同时打开回调返回的PID无效小于等于0不存在就直接返回错误\n4.如果指定的参数PID无效小于等于0不存在同时打开回调返回的PID有效大于0并存在就用打开回调返回的PID覆盖指定参数的PID
3.2方式三是通过窗口句柄安装插件那么返回值应该为打开进程的句柄,并把传递的句柄参数给覆盖了(请看窗口句柄覆盖策略),可以返回小于等于0的错误值或者窗口句柄无效,从而中断安装插件退出,不做相应的安装插件流程(初始化序号-获取PID-加载环境-等待20-继续-等待120),并把打开回调返回值当作安装插件返回值返回。
3.2.1窗口句柄覆盖策略
\n1.如果指定参数的窗口句柄有效同时打开回调返回的的句柄有效就用打开回调返回的句柄覆盖指定参数的句柄\n2.如果指定参数的窗口句柄有效同时打开回调返回的的句柄无效就用指定参数的句柄\n3.如果指定参数的窗口句柄无效同时打开回调返回的的句柄无效就直接返回错误\n4.如果指定参数的窗口句柄无效同时打开回调返回的的句柄有效就用打开回调返回的句柄覆盖指定参数的句柄
检查回调checkFun:
typedef__int64 (__stdcall* CHECKINSTALLPLUGint YPE)(int windowsIndex,int preWindowsIndex,int prePid,int error);
参数:windowsIndex:当前指定序号preWindowsIndex:之前绑定的序号或者错误值(小于0)--来源HCInject_GetPreWinIndex返回prePid:之前绑定的序号对应的PID--来源HCInject_GetPid返回error:提示值
error==RET_重连窗口(5)----->返回值含义:(1重连直接进行加载环境0新窗口)
error== RET_检查PID存在(8)----->触发条件:内部检查是PID不存在触发,这种情况一般是隐藏PID导致的或者真实不存在 返回值含义 :(大于0表示开发者认为prepid参数指定的PID是存在的)  我们一般返回-1或者0就行,除非有特殊情况,比如隐藏了进程导致内部遍历系统拿不到PID这个时候会发送RET_检查PID存在(8)告知开发者来做处理 
error==RET_重连窗口序号不一致(6)----->返回值含义:(1重连并使用之前绑定的序号进行加载环境0新窗口(需要用户在回调中把之前PID给关闭))
说明:
1.如果指定的检查回调为NULL,当内部检查到是重连窗口的时候
2.如果发现序号不一致就会直接返回(ERROR_当前进程插件序号不一致-1216)
3.如果序号一致就直接加载环境并实现重连
几个核心的点归纳总结出来其实就能规避掉很多坑了比如1.没安装过插件的都不算重连窗口全部当新窗口处理会触发打开回调2.安装过插件的不管是卸载了环境还是崩溃了中控都算重连窗口不会触发打开回调
```
### HD扩展_安装插件3 - 基础示例
```python
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```
### HD扩展_安装插件3 - 进阶用法
```python
# Python 示例2
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```
### HD扩展_安装插件3 - 高级应用
```python
# Python 示例3 高级用法
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```

---
## 📌 函数: HD扩展_安装插件VM
### 描述
```
打开后安装通过PID针对虚拟机内部自动关联虚拟机如果使用HD多线程模块强烈建议在登录回调中使用
```
### 原型
```cpp
__int64 __stdcall HDEX_InstallPluginVM(__int32 winIndex,int funType,int vmPid,int vncPort,int appType,__int64 openFun=NULL,__int64 checkFun=NULL,int timeOut=30000);
```
### 参数
```
__int32 winIndex - 窗口序号
int funType - 内部安装插件接口类型查看安装插件接口类型表支持357从第二种继承过来的用法一样
int vmPid - 虚拟机PID或者打开回调指定
int vncPort - 虚拟机VNC端口-1表示不连接VNC大于0表示连接VNC(会断开后重新连接)0为使用之前的缓存VNC端口(会断开后重新连接)
int appType - 进程类型32/64
__int64 openFun - 打开回调回调类型
__int64 checkFun - 检查回调回调类型
int timeOut - 超时时间
```
### 返回值
```
查看返回值表
```
### 注意事项
```
可以参考表安装插件接口类型表
1.调用之前记得打开服务器HCVMDMA_StartServer并确定正确打开HCVMDMA_ServerIsStart
2.其他规则和前3种安装插件方式一致
3.支持重连,重连的前提是不能被HCEnv_UnLoad卸载
回调解析:
打开回调openFun:可以参考表安装插件接口类型表
typedef__int64 (__stdcall* INSTALLPLUGint YPE)(int windowsIndex);
参数:windowsIndex:当前指定序号
说明:1.对于第一种方式打开回调不能为NULL,内部先安装插件再触发回调打开进程(在打开回调中可以手动或者自动打开进程1.如果是手动直接返回1就行或错误值表示中断操作2.如果是自动返回对应的PID或错误值表示中断操作)2.其他二种方式打开回调可以为NULL,表示进程已经打开了,不需要在回调中打开,此时使用指定的PID或者窗口句柄来安装插件,具体是PID还是句柄请查看安装插件接口类型表3.返回值根据当前的安装插件方式不同有不同的含义:（具体请看安装插件接口类型表和覆盖策略）
3.1方式二是通过PID安装插件那么返回值应该为打开进程的PID,并把传递的PID参数给覆盖了(请看PID覆盖策略),可以返回小于等于0的错误值或者不存在的PID,从而中断安装插件退出,不做相应的安装插件流程(初始化序号-获取PID-加载环境-等待20-继续-等待120),并把打开回调返回值当作安装插件返回值返回。
3.1.1PID覆盖策略
\n1.如果指定的参数PID有效大于0并存在同时打开回调返回的PID有效大于0并存在就用打开回调返回的PID覆盖指定参数的PID\n2.如果指定的参数PID有效大于0并存在同时打开回调返回的PID无效小于等于0不存在就用指定参数的PID\n3.如果指定的参数PID无效小于等于0不存在同时打开回调返回的PID无效小于等于0不存在就直接返回错误\n4.如果指定的参数PID无效小于等于0不存在同时打开回调返回的PID有效大于0并存在就用打开回调返回的PID覆盖指定参数的PID
3.2方式三是通过窗口句柄安装插件那么返回值应该为打开进程的句柄,并把传递的句柄参数给覆盖了(请看窗口句柄覆盖策略),可以返回小于等于0的错误值或者窗口句柄无效,从而中断安装插件退出,不做相应的安装插件流程(初始化序号-获取PID-加载环境-等待20-继续-等待120),并把打开回调返回值当作安装插件返回值返回。
3.2.1窗口句柄覆盖策略
\n1.如果指定参数的窗口句柄有效同时打开回调返回的的句柄有效就用打开回调返回的句柄覆盖指定参数的句柄\n2.如果指定参数的窗口句柄有效同时打开回调返回的的句柄无效就用指定参数的句柄\n3.如果指定参数的窗口句柄无效同时打开回调返回的的句柄无效就直接返回错误\n4.如果指定参数的窗口句柄无效同时打开回调返回的的句柄有效就用打开回调返回的句柄覆盖指定参数的句柄
检查回调checkFun:
typedef__int64 (__stdcall* CHECKINSTALLPLUGint YPE)(int windowsIndex,int preWindowsIndex,int prePid,int error);
参数:windowsIndex:当前指定序号preWindowsIndex:之前绑定的序号或者错误值(小于0)--来源HCInject_GetPreWinIndex返回prePid:之前绑定的序号对应的PID--来源HCInject_GetPid返回error:提示值
error==RET_重连窗口(5)----->返回值含义:(1重连直接进行加载环境0新窗口)
error== RET_检查PID存在(8)----->触发条件:内部检查是PID不存在触发,这种情况一般是隐藏PID导致的或者真实不存在 返回值含义 :(大于0表示开发者认为prepid参数指定的PID是存在的)  我们一般返回-1或者0就行,除非有特殊情况,比如隐藏了进程导致内部遍历系统拿不到PID这个时候会发送RET_检查PID存在(8)告知开发者来做处理 
error==RET_重连窗口序号不一致(6)----->返回值含义:(1重连并使用之前绑定的序号进行加载环境0新窗口(需要用户在回调中把之前PID给关闭))
说明:
1.如果指定的检查回调为NULL,当内部检查到是重连窗口的时候
2.如果发现序号不一致就会直接返回(ERROR_当前进程插件序号不一致-1216)
3.如果序号一致就直接加载环境并实现重连
几个核心的点归纳总结出来其实就能规避掉很多坑了比如1.没安装过插件的都不算重连窗口全部当新窗口处理会触发打开回调2.安装过插件的不管是卸载了环境还是崩溃了中控都算重连窗口不会触发打开回调
```
### HD扩展_安装插件VM - 基础示例
```python
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```
### HD扩展_安装插件VM - 进阶用法
```python
# Python 示例2
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```
### HD扩展_安装插件VM - 高级应用
```python
# Python 示例3 高级用法
# Python示例代码
# 这里可以放置与说明内容相关的代码示例
代码内容
```

---
