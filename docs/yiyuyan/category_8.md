---
sidebar_position: 9
---

# 🛰️ 多线程模块[MT]
## 📌 函数: HD多线程_初始化流程回调
### 描述
```
初始化多线程设置相关流程回调
```
### 原型
```cpp
__int64 __stdcall HCMT_InitProcess(__int64 hwnd,void* updateUICallBack,void* loginCallBack,void* firstCallBack,void* secondCallBack,void* endCallBack,void* restartPreCallBack);
```
### 参数
```
__int64 hwnd - 中控UI的窗口主句柄内部会HOOK窗口过程updateUICallBack
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.普通回调1参数windowsIndex:代表的是窗口序号也是主序号
2.每个回调参数的函数类型不一样,注意对应
回调触发顺序:
开启窗口:登录回调--->第一/第二执行回调同时开启--->结束回调
重启窗口:重启前回调--->登录回调--->第一/第二执行回调同时开启--->结束回调
参数回调函数类型:
------------------------------------------------------------------------------------普通回调1
typedef__int64 (__stdcall* FUNTYPE)(__int32 windowsIndex);
windowsIndex:窗口序号
------------------------------------------------------------------------------------普通回调2
typedef__int64 (__stdcall* FUNTYPE)(__int32 index);
index:窗口序号/主序号/副序号
------------------------------------------------------------------------------------UI回调typedef__int64 (__stdcall* UIFUNTYPE)(__int32 windowsIndex,char* stepText,BOOL end1,BOOL pause1,__int32 threadState1,BOOL m_end2,BOOL m_pause2,__int32 threadState2);
windowsIndex:窗口序号
stepText:日志信息/操作信息
end1:主执行线程的结束标志状态
pause1:主执行线程的暂停标志状态
threadState1:主执行线程的线程操作状态
end2:副线程的结束标志状态
pause2:副线程的暂停标志状态
threadState2:副线程的线程操作状态
------------------------------------------------------------------------------------消息回调typedef__int64 (__stdcall* MSGFUNTYPE)(WPARAMwparam,,LPARAMlparam);
wparam:自定义参数1
lparam:自定义参数2
```
### HD多线程_初始化流程回调 - 基础示例
```e-lang
.版本 2

.子程序 _管理员打开进程
    .局部变量 进程ID, 长整数型
    
    进程ID = HD系统_管理员打开进程 ("cmd.exe")
    调试输出 ("管理员进程ID: " + 到文本 (进程ID))
```
### HD多线程_初始化流程回调 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_初始化流程回调 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_初始化流程回调Ex
### 描述
```
初始化多线程设置相关流程回调可以绑定一个全局参数
```
### 原型
```cpp
__int64 __stdcall HCMT_InitProcessEx(__int64 hwnd,void* updateUICallBackEx,void* loginCallBack,void* firstCallBack,void* secondCallBack,void* endCallBack,void* restartPreCallBack,void* lparam);
```
### 参数
```
__int64 hwnd - 中控UI的窗口主句柄内部会HOOK窗口过程updateUICallBack
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.普通回调1参数windowsIndex:代表的是窗口序号也是主序号
2.每个回调参数的函数类型不一样,注意对应
回调触发顺序:
开启窗口:登录回调--->第一/第二执行回调同时开启--->结束回调
重启窗口:重启前回调--->登录回调--->第一/第二执行回调同时开启--->结束回调
参数回调函数类型:
------------------------------------------------------------------------------------普通回调1
typedef__int64 (__stdcall* FUNTYPE)(__int32 windowsIndex);
windowsIndex:窗口序号
------------------------------------------------------------------------------------普通回调2
typedef__int64 (__stdcall* FUNTYPE)(__int32 index);
index:窗口序号/主序号/副序号
------------------------------------------------------------------------------------UI回调EXtypedef__int64 (__stdcall* UIFUNTYPEEX)(__int32 windowsIndex,char* stepText,void* lparam,BOOL m_end1,BOOL m_pause1,__int32 threadState1,BOOL m_end2,BOOL m_pause2,__int32 threadState2);
windowsIndex:窗口序号
stepText:日志信息/操作信息
lparam:HCMT_InitProcessEx绑定一个全局参数,一般我们指定为一个UI对象地址,这个回调可以拿到这个地址
end1:主执行线程的结束标志状态
pause1:主执行线程的暂停标志状态
threadState1:主执行线程的线程操作状态
end2:副线程的结束标志状态
pause2:副线程的暂停标志状态
threadState2:副线程的线程操作状态
------------------------------------------------------------------------------------消息回调typedef__int64 (__stdcall* MSGFUNTYPE)(WPARAMwparam,,LPARAMlparam);
wparam:自定义参数1
lparam:自定义参数2
```
### HD多线程_初始化流程回调Ex - 基础示例
```e-lang
HD智能识图_找图ExA (窗口序号, 图片名字集合, 相似度, 是否灰度图, 是否打开查看器, 返回的HD_2个坐标)
```
### HD多线程_初始化流程回调Ex - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_初始化流程回调Ex - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_初始化操作回调
### 描述
```
初始化多线程结束/暂停/恢复状态的操作回调
```
### 原型
```cpp
__int64 __stdcall HCMT_InitOperate(void* endBindCallBack,void* pauseBindCallBack,void* recoverBindCallBack);
```
### 参数
```
void endBindCallBack - FUNTYPE结束绑定回调当调用HCMT_SetStop/HCMT_SetAllStop会触发pauseBindCallBack
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.仅仅对于这3个回调而言普通回调2参数index:大于多开限制数量,就是副序号;小于就是主序号(也是窗口序号);计算公式:if(index>=多开限制数)主序号=index-多开限制数;
\n(index>=多开环境数量)?(index-多开环境数量):(index)2.其他接口的windowsIndex就代表的是窗口序号也是主序号3.多开限制数量最大常量为31,请自行在程序里面定义
4.多开限制数量用HCEnv_GetMaxWindowNum返回一个常数,可以自己写成一个常量
回调触发顺序:
结束窗口操作:endBindCallBack并传递对应的线程序号(线程序号可能是主序号也就是窗口序号,也有可能是副序号)
暂停窗口操作:pauseBindCallBack并传递对应的线程序号(线程序号可能是主序号也就是窗口序号,也有可能是副序号)
恢复窗口操作:recoverBindCallBack并传递对应的线程序号(线程序号可能是主序号也就是窗口序号,也有可能是副序号)
参数回调函数类型:
------------------------------------------------------------------------------------普通回调1
typedef__int64 (__stdcall* FUNTYPE)(__int32 windowsIndex);
windowsIndex:窗口序号
------------------------------------------------------------------------------------普通回调2
typedef__int64 (__stdcall* FUNTYPE)(__int32 index);
index:窗口序号/主序号/副序号
------------------------------------------------------------------------------------UI回调typedef__int64 (__stdcall* UIFUNTYPE)(__int32 windowsIndex,char* stepText,BOOL end1,BOOL pause1,__int32 threadState1,BOOL m_end2,BOOL m_pause2,__int32 threadState2);
windowsIndex:窗口序号
stepText:日志信息/操作信息
end1:主执行线程的结束标志状态
pause1:主执行线程的暂停标志状态
threadState1:主执行线程的线程操作状态
end2:副线程的结束标志状态
pause2:副线程的暂停标志状态
threadState2:副线程的线程操作状态
------------------------------------------------------------------------------------消息回调typedef__int64 (__stdcall* MSGFUNTYPE)(WPARAMwparam,,LPARAMlparam);
wparam:自定义参数1
lparam:自定义参数2
```
### HD多线程_初始化操作回调 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_初始化操作回调 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_注册消息回调
### 描述
```
注册窗口消息
```
### 原型
```cpp
__int64 __stdcall HCMT_RegisterMessage(__int32 msg,void* msgCallBack);
```
### 参数
```
__int32 msg - 自定义消息整数值(规定值大于等于41124)msgCallBack
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.通过HCMT_MsgSend/HCMT_MsgPost来触发回调
参数回调函数类型:
------------------------------------------------------------------------------------普通回调1
typedef__int64 (__stdcall* FUNTYPE)(__int32 windowsIndex);
windowsIndex:窗口序号
------------------------------------------------------------------------------------普通回调2
typedef__int64 (__stdcall* FUNTYPE)(__int32 index);
index:窗口序号/主序号/副序号
------------------------------------------------------------------------------------UI回调typedef__int64 (__stdcall* UIFUNTYPE)(__int32 windowsIndex,char* stepText,BOOL end1,BOOL pause1,__int32 threadState1,BOOL m_end2,BOOL m_pause2,__int32 threadState2);
windowsIndex:窗口序号
stepText:日志信息/操作信息
end1:主执行线程的结束标志状态
pause1:主执行线程的暂停标志状态
threadState1:主执行线程的线程操作状态
end2:副线程的结束标志状态
pause2:副线程的暂停标志状态
threadState2:副线程的线程操作状态
------------------------------------------------------------------------------------消息回调typedef__int64 (__stdcall* MSGFUNTYPE)(WPARAMwparam,LPARAMlparam);
wparam:自定义参数1
lparam:自定义参数2
```
### HD多线程_注册消息回调 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_注册消息回调 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_同步发送消息
### 描述
```
发送消息(同步)
```
### 原型
```cpp
__int64 __stdcall HCMT_MsgSend(__int32 msg,void* wparam,void* lparam);
```
### 参数
```
__int32 msg - 消息整数值wparam
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
参数回调函数类型:
------------------------------------------------------------------------------------普通回调1
typedef__int64 (__stdcall* FUNTYPE)(__int32 windowsIndex);
windowsIndex:窗口序号
------------------------------------------------------------------------------------普通回调2
typedef__int64 (__stdcall* FUNTYPE)(__int32 index);
index:窗口序号/主序号/副序号
------------------------------------------------------------------------------------UI回调typedef__int64 (__stdcall* UIFUNTYPE)(__int32 windowsIndex,char* stepText,BOOL end1,BOOL pause1,__int32 threadState1,BOOL m_end2,BOOL m_pause2,__int32 threadState2);
windowsIndex:窗口序号
stepText:日志信息/操作信息
end1:主执行线程的结束标志状态
pause1:主执行线程的暂停标志状态
threadState1:主执行线程的线程操作状态
end2:副线程的结束标志状态
pause2:副线程的暂停标志状态
threadState2:副线程的线程操作状态
------------------------------------------------------------------------------------消息回调typedef__int64 (__stdcall* MSGFUNTYPE)(WPARAMwparam,,LPARAMlparam);
wparam:自定义参数1
lparam:自定义参数2
```
### HD多线程_同步发送消息 - 基础示例
```e-lang
.版本 2

.子程序 _发送按键示例
    .局部变量 发送结果, 逻辑型
    .局部变量 窗口序号, 整数型
    .局部变量 窗口句柄, 长整数型
    .局部变量 按键码, 整数型
    
    窗口序号 = 0
    窗口句柄 = 寻找窗口 ("", "记事本")
    按键码 = 13  ' 回车键
    
    .如果 (窗口句柄 ≠ 0)
        发送结果 = HD键鼠_句柄发送按键 (窗口序号, 窗口句柄, 按键码, 0)
        
        .如果 (发送结果 = 真)
            调试输出 ("按键发送成功")
        .否则
            调试输出 ("按键发送失败")
        .如果结束
    .否则
        调试输出 ("未找到目标窗口")
    .如果结束
```
### HD多线程_同步发送消息 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_同步发送消息 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_异步发送消息
### 描述
```
发送消息(异步)
```
### 原型
```cpp
__int64 __stdcall HCMT_MsgPost(__int32 msg,void* wparam,void* lparam);
```
### 参数
```
__int32 msg - 消息整数值wparam
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
参数回调函数类型:
------------------------------------------------------------------------------------普通回调1
typedef__int64 (__stdcall* FUNTYPE)(__int32 windowsIndex);
windowsIndex:窗口序号
------------------------------------------------------------------------------------普通回调2
typedef__int64 (__stdcall* FUNTYPE)(__int32 index);
index:窗口序号/主序号/副序号
------------------------------------------------------------------------------------UI回调typedef__int64 (__stdcall* UIFUNTYPE)(__int32 windowsIndex,char* stepText,BOOL end1,BOOL pause1,__int32 threadState1,BOOL m_end2,BOOL m_pause2,__int32 threadState2);
windowsIndex:窗口序号
stepText:日志信息/操作信息
end1:主执行线程的结束标志状态
pause1:主执行线程的暂停标志状态
threadState1:主执行线程的线程操作状态
end2:副线程的结束标志状态
pause2:副线程的暂停标志状态
threadState2:副线程的线程操作状态
------------------------------------------------------------------------------------消息回调typedef__int64 (__stdcall* MSGFUNTYPE)(WPARAMwparam,,LPARAMlparam);
wparam:自定义参数1
lparam:自定义参数2
```
### HD多线程_异步发送消息 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_异步发送消息 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_开启窗口Msg
### 描述
```
通过消息开启窗口操作
```
### 原型
```cpp
__int64 __stdcall HCMT_MsgStart(__int32 windowsIndex,BOOL bAsyn=FALSE);
```
### 参数
```
__int32 windowsIndex - 窗口序号bAsyn
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.开启成功后会相应触发对应设置的回调函数
3.顺序:
开启窗口:登录回调--->第一/第二执行回调同时开启--->{暂停/恢复/结束绑定回调}->结束回调
重启窗口:重启前回调--->登录回调--->第一/第二执行回调同时开启--->{暂停/恢复/结束绑定回调}->结束回调
停止窗口:结束绑定回调->结束回调
```
### HD多线程_开启窗口Msg - 基础示例
```e-lang
.子程序 _测试OCR服务启动
    .局部变量 窗口索引, 整数型
    .局部变量 启动结果, 逻辑型
    .局部变量 返回数据, 文本型
    
    窗口索引 = 0
    
    调试输出 ("=== OCR服务启动测试 ===")
    
    ' 第一步：确保已经初始化
    .如果 (HD智能识字_初始化 (窗口索引, "chi_sim") = 假)
        调试输出 ("初始化失败，无法继续启动测试")
        返回 (假)
    .如果结束
    
    调试输出 ("OCR初始化成功，开始启动服务...")
    
    ' 第二步：启动OCR服务
    启动结果 = HD智能识字_启动 (窗口索引)
    返回数据 = HD通用_获取最近返回json (窗口索引)
    
    .如果 (启动结果 = 真)
        调试输出 ("✓ OCR服务启动成功！")
        调试输出 ("返回信息:", 返回数据)
        调试输出 ("OCR服务现在可以执行文字识别任务")
        
        ' 验证服务状态
        调试输出 ("服务状态: 已启动并准备识别")
        返回 (真)
        
    .否则
        调试输出 ("✗ OCR服务启动失败")
        调试输出 ("错误信息:", 返回数据)
        调试输出 ("可能原因:")
        调试输出 ("1. 未正确初始化或初始化失败")
        调试输出 ("2. OCR引擎内部错误")
        调试输出 ("3. 系统资源不足")
        调试输出 ("4. 语言库损坏或不兼容")
        返回 (假)
    .如果结束
```
### HD多线程_开启窗口Msg - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_开启窗口Msg - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_停止窗口Msg
### 描述
```
通过消息停止窗口操作
```
### 原型
```cpp
__int64 __stdcall HCMT_MsgStop(__int32 windowsIndex,BOOL bAsyn=FALSE);
```
### 参数
```
__int32 windowsIndex - 窗口序号bAsyn
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.开启成功后会相应触发对应设置的回调函数
3.顺序:
开启窗口:登录回调--->第一/第二执行回调同时开启--->{暂停/恢复/结束绑定回调}->结束回调
重启窗口:重启前回调--->登录回调--->第一/第二执行回调同时开启--->{暂停/恢复/结束绑定回调}->结束回调
停止窗口:结束绑定回调->结束回调
```
### HD多线程_停止窗口Msg - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_停止窗口Msg - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_重启窗口Msg
### 描述
```
通过消息重启窗口操作
```
### 原型
```cpp
__int64 __stdcall HCMT_MsgReStart(__int32 windowsIndex,BOOL bAsyn=FALSE);
```
### 参数
```
__int32 windowsIndex - 窗口序号bAsyn
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.开启成功后会相应触发对应设置的回调函数
3.顺序:
开启窗口:登录回调--->第一/第二执行回调同时开启--->{暂停/恢复/结束绑定回调}->结束回调
重启窗口:重启前回调--->登录回调--->第一/第二执行回调同时开启--->{暂停/恢复/结束绑定回调}->结束回调
停止窗口:结束绑定回调->结束回调
```
### HD多线程_重启窗口Msg - 基础示例
```e-lang
.版本 2

.子程序 测试开启VNC截图, 逻辑型, 公开
    .局部变量 窗口序号, 整数型
    .局部变量 结果, 逻辑型
    
    窗口序号 ＝ 1
    
    调试输出 ("准备开启VNC截图功能")
    调试输出 ("窗口序号：", 窗口序号)
    
    ' 开启VNC截图功能
    结果 ＝ HDVNC_开启截图 (窗口序号)
    .如果 (结果 ＝ 真)
        调试输出 ("VNC截图功能已开启")
        调试输出 ("开始循环获取虚拟机画面")
        调试输出 ("现在可以使用HD截图相关功能")
    .否则
        调试输出 ("开启VNC截图功能失败")
        调试输出 ("请检查VNC连接状态")
    .如果结束
    
    返回 (结果)
```
### HD多线程_重启窗口Msg - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_重启窗口Msg - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_重启窗口MsgEx
### 描述
```
通过消息重启窗口操作(扩展版本)
```
### 原型
```cpp
__int64 __stdcall HCMT_MsgReStartEx(__int32 windowsIndex,BOOL bUnload=TRUE,BOOL bAsyn=FALSE);
```
### 参数
```
__int32 windowsIndex - 窗口序号
bool bUnload - 是否重启前卸载进程环境(HCEnv_UnLoad)一般我们肯定要卸载环境的尤其是在配合心跳HCEnv_AttachHeart的时候
bool bAsyn - 是否异步发送
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.开启成功后会相应触发对应设置的回调函数
3.顺序:
开启窗口:登录回调--->第一/第二执行回调同时开启--->{暂停/恢复/结束绑定回调}->结束回调
重启窗口:重启前回调--->登录回调--->第一/第二执行回调同时开启--->{暂停/恢复/结束绑定回调}->结束回调
停止窗口:结束绑定回调->结束回调
```
### HD多线程_重启窗口MsgEx - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_重启窗口MsgEx - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_更新UI
### 描述
```
通过消息触发UI回调,并传递线程状态信息和日志操作信息给UI回调
```
### 原型
```cpp
__int64 __stdcall HCMT_MsgUpdateUI(__int32 windowsIndex,BOOL bAsyn=FALSE);
```
### 参数
```
__int32 windowsIndex - 窗口序号bAsyn
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
```
### HD多线程_更新UI - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_更新UI - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_发送文本
### 描述
```
通过消息触发UI回调,并传递线程状态信息和日志操作信息给UI回调
```
### 原型
```cpp
__int64 __stdcall HCMT_MsgStepText(__int32 windowsIndex,char* text,BOOL bAsyn=FALSE);
```
### 参数
```
__int32 windowsIndex - 窗口序号text
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
```
### HD多线程_发送文本 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_发送文本 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_所有窗口暂停
### 描述
```
设置所有窗口结束
```
### 原型
```cpp
__int64 __stdcall HCMT_SetAllPause();
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.标志会在HCMT_Sleep接口中检查并触发对应的暂停绑定回调
```
### HD多线程_所有窗口暂停 - 基础示例
```e-lang
.版本 2

.子程序 测试设置延迟, 逻辑型, 公开
    .局部变量 窗口序号, 整数型
    .局部变量 延迟毫秒, 整数型
    .局部变量 结果, 逻辑型
    
    窗口序号 ＝ 1
    延迟毫秒 ＝ 25  ' 25毫秒延迟
    
    ' 设置延迟时间
    结果 ＝ HD优化_设置延迟 (窗口序号, 延迟毫秒)
    .如果 (结果 ＝ 真)
        调试输出 ("延迟设置成功：", 延迟毫秒, "ms")
        调试输出 ("适用于绑定dx.public.down.cpu后台属性")
    .否则
        调试输出 ("延迟设置失败")
    .如果结束
    
    返回 (结果)
```
### HD多线程_所有窗口暂停 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_所有窗口暂停 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_获取线程状态值
### 描述
```
获取主副序号对应的线程的状态值
```
### 原型
```cpp
__int64 __stdcall HCMT_GetState(__int32 index);
```
### 参数
```
__int32 index - 主副序号注意
```
### 返回值
```
返回1:状态值注意:如果需要转换为字符串,需要调用HCMT_GetStateString
返回其他值:查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.标志会在HCMT_Sleep接口中检查并触发对应的暂停绑定回调
typedefenumTHREADSTATE\n线程状态{THREADSTATE_NONE=-1,\n未启动THREADSTATE_STARTING=0,\n开启中THREADSTATE_LOGINING=1,\n正在登录THREADSTATE_RUNNING=2,\n正在运行THREADSTATE_PAUSE=3,\n暂停THREADSTATE_PAUSEING=4,\n正在暂停THREADSTATE_RECOVERING=5,\n正在恢复THREADSTATE_WILLSTOP=6,\n准备停止THREADSTATE_STOPPING=7\n正在停止}THREADSTATE;
```
### HD多线程_获取线程状态值 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_获取线程状态值 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCMT_GetStateString
### 描述
```
获取状态整数值对应的字符串
```
### 原型
```cpp
char* __stdcall HCMT_GetStateString(__int32 threadState);
```
### 参数
```
__int32 threadState - 状态值
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HCMT_GetStateString - 基础示例
```e-lang
.版本 2

.子程序 ASCII字符串输入示例
    .局部变量 窗口序号, 整数型
    .局部变量 发送结果, 长整数型
    .局部变量 输入文本, 文本型
    
    窗口序号 ＝ 1
    输入文本 ＝ "Hello World! 123456"
    
    ' 发送ASCII字符串
    发送结果 ＝ HCMKB_SendStringA (窗口序号, 输入文本)
    
    .如果 (发送结果 ≥ 1)
        调试输出 ("ASCII字符串发送成功")
        调试输出 ("发送的内容：" ＋ 输入文本)
        
        延时 (1000)
        
        ' 发送回车确认
        HD键鼠_按键 (窗口序号, "return", 50)
        调试输出 ("已按下回车键确认输入")
        
    .否则
        调试输出 ("ASCII字符串发送失败，错误码：" ＋ 到文本 (发送结果))
    .如果结束
```
### HCMT_GetStateString - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCMT_GetStateString - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_是否能开启
### 描述
```
判断是否能开启新的(主副线程)传递的只能是主序号
```
### 原型
```cpp
__int64 __stdcall HCMT_IsCanStart(__int32 windowsIndex);
```
### 参数
```
__int32 windowsIndex - 主序号
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD多线程_是否能开启 - 基础示例
```e-lang
.版本 2

.子程序 测试开启CPU优化, 逻辑型, 公开
    .局部变量 窗口序号, 整数型
    .局部变量 结果, 逻辑型
    
    窗口序号 ＝ 1
    
    ' 开启CPU优化
    结果 ＝ HD优化_开启CPU (窗口序号, 假)
    .如果 (结果 ＝ 真)
        调试输出 ("CPU优化开启成功")
        调试输出 ("后台运行性能将得到提升")
    .否则
        调试输出 ("CPU优化开启失败")
        调试输出 ("请检查驱动环境是否正常")
    .如果结束
    
    返回 (结果)
```
### HD多线程_是否能开启 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_是否能开启 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_开启窗口
### 描述
```
直接开启窗口操作
```
### 原型
```cpp
__int64 __stdcall HCMT_Start(__int32 windowsIndex);
```
### 参数
```
__int32 windowsIndex - 窗口序号
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.开启成功后会相应触发对应设置的回调函数
3.顺序:
开启窗口:登录回调--->第一/第二执行回调同时开启--->{暂停/恢复/结束绑定回调}->结束回调
重启窗口:重启前回调--->登录回调--->第一/第二执行回调同时开启--->{暂停/恢复/结束绑定回调}->结束回调
停止窗口:结束绑定回调->结束回调
```
### HD多线程_开启窗口 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_开启窗口 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_所有窗口恢复
### 描述
```
设置所有窗口恢复
```
### 原型
```cpp
__int64 __stdcall HCMT_SetAllRecover();
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.标志会在HCMT_Sleep接口中检查并触发对应的恢复绑定回调
```
### HD多线程_所有窗口恢复 - 基础示例
```e-lang
.版本 2

.子程序 CPU降频设置示例
    .局部变量 窗口序号, 整数型
    .局部变量 设置结果, 长整数型
    .局部变量 降频毫秒, 整数型
    
    窗口序号 ＝ 1
    降频毫秒 ＝ 50  ' 设置50毫秒的CPU降频
    
    ' 设置CPU降频以降低被检测概率
    设置结果 ＝ HC_SetCpuDwonMs (窗口序号, 降频毫秒)
    
    .如果 (设置结果 ≥ 1)
        调试输出 ("CPU降频设置成功")
        调试输出 ("降频时间：" ＋ 到文本 (降频毫秒) ＋ "毫秒")
        
        ' 执行一些需要降频的操作
        调试输出 ("开始执行低频操作...")
        
        .计次循环首 (10, )
            HD键鼠_左键点击 (窗口序号, 随机数 (100, 800), 随机数 (100, 600))
            延时 (200)
            调试输出 ("执行第" ＋ 到文本 () ＋ "次操作")
        .计次循环尾 ()
        
        ' 恢复正常频率（设为0）
        设置结果 ＝ HC_SetCpuDwonMs (窗口序号, 0)
        
        .如果 (设置结果 ≥ 1)
            调试输出 ("CPU频率已恢复正常")
        .否则
            调试输出 ("CPU频率恢复失败")
        .如果结束
        
    .否则
        调试输出 ("CPU降频设置失败，错误码：" ＋ 到文本 (设置结果))
    .如果结束
```
### HD多线程_所有窗口恢复 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_所有窗口恢复 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_所有窗口停止
### 描述
```
设置所有窗口停止
```
### 原型
```cpp
__int64 __stdcall HCMT_SetAllStop();
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.标志会在HCMT_Sleep接口中检查并触发对应的停止绑定回调
```
### HD多线程_所有窗口停止 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_所有窗口停止 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_暂停窗口
### 描述
```
设置窗口暂停
```
### 原型
```cpp
__int64 __stdcall HCMT_SetPause(__int32 windowsIndex);
```
### 参数
```
__int32 windowsIndex - 窗口序号
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.标志会在HCMT_Sleep接口中检查并触发对应的暂停绑定回调
```
### HD多线程_暂停窗口 - 基础示例
```e-lang
.版本 2

.子程序 测试设置CPU延迟, 逻辑型, 公开
    .局部变量 窗口序号, 整数型
    .局部变量 延迟时间, 整数型
    .局部变量 结果, 逻辑型
    
    窗口序号 ＝ 1
    延迟时间 ＝ 30  ' 30毫秒延迟
    
    ' 设置CPU延迟
    结果 ＝ HD优化_设置CPU延迟 (窗口序号, 延迟时间)
    .如果 (结果 ＝ 真)
        调试输出 ("CPU延迟设置成功：", 延迟时间, "ms")
        调试输出 ("建议延迟范围：20-50ms")
    .否则
        调试输出 ("CPU延迟设置失败")
    .如果结束
    
    返回 (结果)
```
### HD多线程_暂停窗口 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_暂停窗口 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_暂停线程
### 描述
```
设置主副序号对应的线程暂停
```
### 原型
```cpp
__int64 __stdcall HCMT_SetPauseEx(__int32 index);
```
### 参数
```
__int32 index - 主副序号注意
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.标志会在HCMT_Sleep接口中检查并触发对应的暂停绑定回调
```
### HD多线程_暂停线程 - 基础示例
```e-lang
.版本 2

.子程序 测试设置帧数, 逻辑型, 公开
    .局部变量 窗口序号, 整数型
    .局部变量 目标帧数, 整数型
    .局部变量 结果, 逻辑型
    
    窗口序号 ＝ 1
    目标帧数 ＝ 60  ' 设置为60帧
    
    ' 设置帧数参考值
    结果 ＝ HD优化_设置帧数 (窗口序号, 目标帧数)
    .如果 (结果 ＝ 真)
        调试输出 ("帧数设置成功：", 目标帧数, "FPS")
        调试输出 ("这只是参考值，实际帧数可能不同")
    .否则
        调试输出 ("帧数设置失败")
    .如果结束
    
    返回 (结果)
```
### HD多线程_暂停线程 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_暂停线程 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_恢复窗口
### 描述
```
设置窗口恢复
```
### 原型
```cpp
__int64 __stdcall HCMT_SetRecover(__int32 windowsIndex);
```
### 参数
```
__int32 windowsIndex - 窗口序号
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.标志会在HCMT_Sleep接口中检查并触发对应的恢复绑定回调
```
### HD多线程_恢复窗口 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_恢复窗口 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_恢复线程
### 描述
```
设置主副序号对应的线程恢复
```
### 原型
```cpp
__int64 __stdcall HCMT_SetRecoverEx(__int32 index);
```
### 参数
```
__int32 index - 主副序号注意
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.标志会在HCMT_Sleep接口中检查并触发对应的暂停绑定回调
```
### HD多线程_恢复线程 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_恢复线程 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_停止窗口
### 描述
```
设置窗口停止
```
### 原型
```cpp
__int64 __stdcall HCMT_SetStop(__int32 windowsIndex);
```
### 参数
```
__int32 windowsIndex - 窗口序号
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.标志会在HCMT_Sleep接口中检查并触发对应的结束绑定回调
```
### HD多线程_停止窗口 - 基础示例
```e-lang
.版本 2

.子程序 测试设置黑屏范围, 逻辑型, 公开
    .局部变量 窗口序号, 整数型
    .局部变量 新最小型号, 整数型
    .局部变量 新最大型号, 整数型
    .局部变量 结果, 逻辑型
    
    窗口序号 ＝ 1
    新最小型号 ＝ 100  ' 调整最小显卡型号
    新最大型号 ＝ 500  ' 调整最大显卡型号
    
    调试输出 ("设置黑屏范围")
    调试输出 ("新的显卡型号范围：", 新最小型号, " - ", 新最大型号)
    
    ' 设置新的黑屏范围
    结果 ＝ HD黑屏_设置黑屏范围 (窗口序号, 新最小型号, 新最大型号)
    .如果 (结果 ＝ 真)
        调试输出 ("黑屏范围设置成功")
        调试输出 ("黑屏功能已更新为新的型号范围")
    .否则
        调试输出 ("黑屏范围设置失败")
        调试输出 ("请确保黑屏功能已经开启")
    .如果结束
    
    返回 (结果)
```
### HD多线程_停止窗口 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_停止窗口 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_是否运行中
### 描述
```
(第一第二)回调里面调用,检查当前线程是否结束
```
### 原型
```cpp
__int64 __stdcall HCMT_IsRunning();
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD多线程_是否运行中 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_是否运行中 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_是否暂停
### 描述
```
判断主副序号对应的线程是否是已被暂停状态
```
### 原型
```cpp
__int64 __stdcall HCMT_IsPause(__int32 index);
```
### 参数
```
__int32 index - 主副序号注意
```
### 返回值
```
返回1:表示已经暂停
返回0:表示未被暂停
返回其他值:查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.标志会在HCMT_Sleep接口中检查并触发对应的暂停绑定回调
```
### HD多线程_是否暂停 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_是否暂停 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_是否停止
### 描述
```
判断主副序号对应的线程是否是已被结束状态
```
### 原型
```cpp
__int64 __stdcall HCMT_IsStop(__int32 index);
```
### 参数
```
__int32 index - 主副序号注意
```
### 返回值
```
返回1:表示已经结束
返回其他值:查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.标志会在HCMT_Sleep接口中检查并触发对应的暂停绑定回调
```
### HD多线程_是否停止 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_是否停止 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD多线程_延迟
### 描述
```
设延迟函数,自带暂停/结束/恢复检查
```
### 原型
```cpp
__int64 __stdcall HCMT_Sleep(int mis);
```
### 参数
```
int mis - 毫秒
```
### 返回值
```
1:正常
2:线程结束
3.线程被暂停过
其他值:查看返回值表
```
### 注意事项
```
1.HDMT_InitProcess/HCMT_InitOperate后才能调用
2.仅仅设置的是标志位,不会堵塞线程
3.检查随后触发HCMT_InitOperate设置的3个回调;理论上不能在HCMT_InitOperate设置的3个回调中调用,因为会导致无限调用自己(但是内部做了检测所以不会无限调用,也就是如果当前第一次已经检查到标志位并触发对应的绑定回调了,在回调中又再一次调用HCMT_Sleep,那么这一次的HCMT_Sleep只会正常休眠,并不继续检查了,防止无限调用);
3.其他回调均可以(无影响)
4.如果要内部检测状态机状态需要调用HCMT_StatusSleep
```
### HD多线程_延迟 - 进阶用法
```e-lang
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD多线程_延迟 - 高级应用
```e-lang
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
