# 🛰️ 驱动模块(HD)
## 📌 函数: HD驱动_安装
### 描述
```
加载HD驱动(正式版本)
```
### 原型
```
__int64 __stdcall HCHD_LoadDrv();
```
### 返回值
```
查看返回值表
```
### 注意事项
```
需要联网,不可以卸载驱动,可以清除注入DLL缓存
此接口相当于调用HCHD_LoadDrv2传递-1:HDEx正式版本(云下发正常驱动,无特殊处理)
```
### HD驱动_安装 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_安装 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_安装2
### 描述
```
云下发加载驱动或组件(可以通过指定驱动序号,加载不同版本的驱动如:正式版本定制版本备用版本其他保护盾VT等等)
```
### 原型
```
__int64 __stdcall HCHD_LoadDrv2(__int32 type=0);
```
### 参数
```
__int32 type - 驱动序号-1表示
 说明 - 云下发加载驱动或组件-1
 注意 - -1016不能共存其他任意组合都可以共存！！！！
```
### 返回值
```
查看返回值表
```
### 注意事项
```
需要联网,不可以卸载驱动,可以清除注入DLL缓存
```
### HD驱动_安装2 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_安装2 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_初始化快速读写
### 描述
```
初始化HD驱动快速读写(一般在HD安装驱动接口后的下一句就开始初始化)
```
### 原型
```
__int64 __stdcall HCHD_InitFastRW();
```
### 返回值
```
查看返回值表
```
### 注意事项
```
如果最开始安装HD驱动调用的是HCHD_LoadDrv同时又需要快速读写遍历,就需要先调用此接口,然后调用HCHD_RWExx进行快读内存读写遍历(百万级别)
如果最开始安装HD驱动调用的是HCHD_LoadDrv2并传递驱动序号为0,表示可以直接调用HCHD_RWExx进行快读内存读写遍历(百万级别),不需要再调用此接口了
```
### HD驱动_初始化快速读写 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_初始化快速读写 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_无痕注入DLL
### 描述
```
把DLL注入到指定进程中(指定DLL二进制文件数据)
```
### 原型
```
__int64 __stdcall HCHD_InjectX86X64(char* injectExeName,__int32 dllBits,__int32 injectMode,__int32 memoryHide,PVOIDinjectData,__int32 injectSize);
```
### 参数
```
char* injectExeName - 进程名(如
__int32 dllBits - 进程位(32/64)
__int32 injectMode - 注入模式(0/1/2),一般0,1模式就行,2用于steam游戏
__int32 memoryHide - 内存保护模式(0/1/2)
 injectData - 注入数据缓冲区首地址
__int32 injectSize - 注入数据缓冲区大小(单位
```
### 返回值
```
查看返回值表
```
### 注意事项
```
不能卸载驱动,可以清除注入DLL缓存,支持32/64进程
```
### HD驱动_无痕注入DLL - 基础示例
```
.版本 2

.子程序 测试注入JS代码, 逻辑型, 公开
    .局部变量 窗口序号, 整数型
    .局部变量 JS代码, 文本型
    .局部变量 结果, 逻辑型
    
    窗口序号 ＝ 1
    
    ' 准备要注入的JavaScript代码
    JS代码 ＝ "alert('Hello from HD自动化库!');" ＋ #换行符 ＋
             "console.log('JavaScript注入成功!');" ＋ #换行符 ＋
             "document.title = '由HD控制的页面';"
    
    调试输出 ("准备注入JavaScript代码")
    调试输出 ("代码内容：", JS代码)
    
    ' 注入JavaScript代码
    结果 ＝ HD内置浏览器_注入谷歌JS代码 (窗口序号, JS代码, 假)
    .如果 (结果 ＝ 真)
        调试输出 ("JavaScript代码注入成功")
        调试输出 ("代码已在浏览器中执行")
    .否则
        调试输出 ("JavaScript代码注入失败")
        调试输出 ("请确保已正确附加到Chrome浏览器")
    .如果结束
    
    返回 (结果)
```
### HD驱动_无痕注入DLL - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_无痕注入DLL - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCHD_InjectX86X64ByFile
### 描述
```
把DLL注入到指定进程中(指定DLL文件路径)
```
### 原型
```
__int64 __stdcall HCHD_InjectX86X64ByFile(char* injectExeName,__int32 dllBits,__int32 injectMode,__int32 memoryHide,char* DLL绝对路径A);
```
### 参数
```
char* injectExeName - 进程名(如
__int32 dllBits - 进程位(32/64)
__int32 injectMode - 注入模式(0/1/2),一般0,1模式就行,2用于steam游戏
__int32 memoryHide - 内存保护模式(0/1/2)
char* DLL绝对路径A - DLL绝对路径A
```
### 返回值
```
查看返回值表
```
### 注意事项
```
不能卸载驱动,可以清除注入DLL缓存,支持32/64进程
```
### HCHD_InjectX86X64ByFile - 基础示例
```
.子程序 _测试从文件模板匹配
    .局部变量 原图文件, 文本型
    .局部变量 模板集合, 文本型
    .局部变量 匹配索引, 整数型
    .局部变量 匹配X, 整数型
    .局部变量 匹配Y, 整数型
    .局部变量 匹配数组, HD_2个坐标, 数组
    
    原图文件 = "D:\Screenshots\game_screenshot.jpg"
    模板集合 = "ui_button.bmp|menu_icon.bmp|status_bar.bmp"
    
    ' 验证原图文件是否存在
    .如果 (文件是否存在 (原图文件) = 假)
        调试输出 ("原图文件不存在:", 原图文件)
        返回 (假)
    .如果结束
    
    调试输出 ("开始从文件进行模板匹配...")
    调试输出 ("原图文件:", 原图文件)
    调试输出 ("模板集合:", 模板集合)
    
    ' 执行文件模板匹配
    匹配索引 = HD智能识图_Tem找图从文件 (0, 原图文件, 模板集合, 0.85, 5, 真, 真, 假, 匹配X, 匹配Y, 匹配数组)
    
    .如果 (匹配索引 ≥ 0)
        调试输出 ("文件模板匹配成功！")
        调试输出 ("匹配模板序号:", 匹配索引)
        调试输出 ("最优坐标: (", 匹配X, ",", 匹配Y, ")")
        
        .局部变量 模板名称, 文本型, , , "3"
        模板名称 [1] = "UI按钮"
        模板名称 [2] = "菜单图标"
        模板名称 [3] = "状态栏"
        
        .如果 (匹配索引 < 3)
            调试输出 ("识别到:", 模板名称 [匹配索引 + 1])
        .如果结束
        
        ' 显示所有匹配结果
        .如果 (取数组成员数 (匹配数组) > 0)
            调试输出 ("所有匹配结果:")
            .局部变量 j, 整数型
            .计次循环首 (取数组成员数 (匹配数组), j)
                调试输出 ("  匹配", j, ": 矩形(", 匹配数组 [j].x1, ",", 匹配数组 [j].y1, "," + 到文本 (匹配数组 [j].x2), ",", 匹配数组 [j].y2, ") 相似度:", 匹配数组 [j].sim)
            .计次循环尾 ()
        .如果结束
        
        返回 (真)
    .否则
        调试输出 ("文件模板匹配失败")
        返回 (假)
    .如果结束
```
### HCHD_InjectX86X64ByFile - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCHD_InjectX86X64ByFile - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCHD_InstallPlug(86/64)
### 描述
```
安装HD插件到指定进程中
```
### 原型
```
__int64 __stdcall HCHD_InstallPlugX86(char* injectExeName,__int32 injectMode,__int32 memoryHide);
```
```
__int64 __stdcall HCHD_InstallPlugX64(char* injectExeName,__int32 injectMode,__int32 memoryHide);
```
### 参数
```
char* injectExeName - 进程名(如
__int32 injectMode - 注入模式(0/1/2),一般0,1模式就行,2用于steam游戏
__int32 memoryHide - 内存保护模式(0/1/2)
```
### 返回值
```
查看返回值表
```
### 注意事项
```
需要联网,可以清除注入DLL缓存,支持32/64进程
```
### HCHD_InstallPlug(86/64) - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCHD_InstallPlug(86/64) - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_卸载插件
### 描述
```
卸载插件(并不是从进程中卸载,而是清除了下一次进程打开的时候安装插件的缓存)
```
### 原型
```
__int64 __int64 __stdcall HCHD_UnInstallPlug();
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_卸载插件 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_卸载插件 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_前台鼠标移动点击
### 描述
```
前台驱动鼠标移动并点击
```
### 原型
```
__int64 __stdcall HCHD_MousePress(__int32 abx,__int32 aby,__int32 mButCode,__int32 mis);
```
### 参数
```
__int32 X - 屏幕坐标X
__int32 X - 屏幕坐标Y
__int32 mButCode - 
__int32 mButCode 鼠标移动时鼠标按钮的值如下 指定0表示移动不按键 - #defineMOUSE_BUTTON_1_DOWN1左按下#defineMOUSE_BUTTON_1_UP2左弹起#defineMOUSE_BUTTON_2_DOWN4中按下#defineMOUSE_BUTTON_2_UP8中弹起#defineMOUSE_BUTTON_3_DOWN16右按下#defineMOUSE_BUTTON_3_UP32右弹起
__int32 mis - 按下和弹起之间的毫秒差
```
### 返回值
```
查看返回值表
```
### 注意事项
```
可以通过调用HCHD_SetMMTrackType来设置鼠标全局移动轨迹类型
按键在轨迹坐标集中那些坐标有效:第一个点操作按键-中间点不操作按键-最后一个点不操作按键
```
### HD驱动_前台鼠标移动点击 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_前台鼠标移动点击 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_前台鼠标移动点击Ex
### 描述
```
前台驱动鼠标移动并点击(可指定句柄)
```
### 原型
```
__int64 __stdcall HCHD_MousePressEx(__int64 hwnd,__int32 x,__int32 y,__int32 mButCode,__int32 mis);
```
### 参数
```
__int64 hwnd - 窗口句柄
__int32 X - 窗口客户区坐标X
__int32 X - 窗口客户区坐标Y
__int32 mButCode - 
__int32 mButCode 鼠标移动时鼠标按钮的值如下 指定0表示移动不按键 - #defineMOUSE_BUTTON_1_DOWN1左按下#defineMOUSE_BUTTON_1_UP2左弹起#defineMOUSE_BUTTON_2_DOWN4中按下#defineMOUSE_BUTTON_2_UP8中弹起#defineMOUSE_BUTTON_3_DOWN16右按下#defineMOUSE_BUTTON_3_UP32右弹起
__int32 mis - 按下和弹起之间的毫秒差
```
### 返回值
```
查看返回值表
```
### 注意事项
```
可以通过调用HCHD_SetMMTrackType来设置鼠标全局移动轨迹类型
按键在轨迹坐标集中那些坐标有效:第一个点操作按键-中间点不操作按键-最后一个点不操作按键
```
### HD驱动_前台鼠标移动点击Ex - 基础示例
```
.版本 2

.子程序 测试前台驱动鼠标按住, 长整数型, 公开
    .局部变量 窗口句柄, 整数型
    .局部变量 按住X, 整数型
    .局部变量 按住Y, 整数型
    .局部变量 鼠标键, 整数型
    .局部变量 结果, 长整数型
    
    ' 获取画图程序窗口
    窗口句柄 ＝ 取到整数 (寻找窗口 ("", "画图"))
    .如果 (窗口句柄 ＝ 0)
        调试输出 ("未找到画图程序窗口")
        返回 (0)
    .如果结束
    
    ' 设置按住参数
    按住X ＝ 150
    按住Y ＝ 100
    鼠标键 ＝ 1  ' 左键按住
    
    调试输出 ("准备执行前台驱动鼠标按住")
    调试输出 ("窗口句柄：", 窗口句柄)
    调试输出 ("按住位置：(", 按住X, ",", 按住Y, ")")
    
    ' 执行前台驱动鼠标按住
    结果 ＝ HD驱动前台_前台鼠标按住 (窗口句柄, 按住X, 按住Y, 鼠标键)
    .如果 (结果 ＞ 0)
        调试输出 ("前台驱动鼠标按住成功")
        调试输出 ("鼠标左键已按住，可进行拖拽操作")
    .否则
        调试输出 ("前台驱动鼠标按住失败")
    .如果结束
    
    返回 (结果)
```
### HD驱动_前台鼠标移动点击Ex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_前台鼠标移动点击Ex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_前台鼠标移动按下
### 描述
```
前台驱动鼠标移动并按下指定键(可指定句柄)
```
### 原型
```
__int64 __stdcall HCHD_MouseDown(__int64 hwnd,__int32 x,__int32 y,__int32 mButCode);
```
### 参数
```
__int64 hwnd - 窗口句柄
__int32 X - 窗口客户区坐标X
__int32 X - 窗口客户区坐标Y
__int32 mButCode - 
__int32 mButCode 鼠标移动时鼠标按钮的值如下 指定0表示移动不按键 - #defineMOUSE_BUTTON_1_DOWN1左按下#defineMOUSE_BUTTON_2_DOWN4中按下#defineMOUSE_BUTTON_3_DOWN16右按下
```
### 返回值
```
查看返回值表
```
### 注意事项
```
可以通过调用HCHD_SetMMTrackType来设置鼠标全局移动轨迹类型
按键在轨迹坐标集中那些坐标有效:第一个点操作按键-中间点不操作按键-最后一个点不操作按键
```
### HD驱动_前台鼠标移动按下 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_前台鼠标移动按下 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_前台鼠标移动弹起
### 描述
```
前台驱动鼠标移动并弹起指定键(可指定句柄)
```
### 原型
```
__int64 __stdcall HCHD_MouseUp(__int64 hwnd,__int32 x,__int32 y,__int32 mButCode);
```
### 参数
```
__int64 hwnd - 窗口句柄
__int32 X - 窗口客户区坐标X
__int32 X - 窗口客户区坐标Y
__int32 mButCode - 
__int32 mButCode 鼠标移动时鼠标按钮的值如下 指定0表示移动不按键 - #defineMOUSE_BUTTON_1_UP2左弹起#defineMOUSE_BUTTON_2_UP8中弹起#defineMOUSE_BUTTON_3_UP32右弹起
```
### 返回值
```
查看返回值表
```
### 注意事项
```
可以通过调用HCHD_SetMMTrackType来设置鼠标全局移动轨迹类型
按键在轨迹坐标集中那些坐标有效:第一个点操作按键-中间点不操作按键-最后一个点不操作按键
```
### HD驱动_前台鼠标移动弹起 - 基础示例
```
.版本 2

.子程序 测试前台驱动鼠标弹起, 长整数型, 公开
    .局部变量 窗口句柄, 整数型
    .局部变量 弹起X, 整数型
    .局部变量 弹起Y, 整数型
    .局部变量 鼠标键, 整数型
    .局部变量 结果, 长整数型
    
    ' 获取画图程序窗口
    窗口句柄 ＝ 取到整数 (寻找窗口 ("", "画图"))
    .如果 (窗口句柄 ＝ 0)
        调试输出 ("未找到画图程序窗口")
        返回 (0)
    .如果结束
    
    ' 设置弹起参数
    弹起X ＝ 200
    弹起Y ＝ 150
    鼠标键 ＝ 1  ' 左键弹起
    
    调试输出 ("准备执行前台驱动鼠标弹起")
    调试输出 ("弹起位置：(", 弹起X, ",", 弹起Y, ")")
    
    ' 执行前台驱动鼠标弹起
    结果 ＝ HD驱动前台_前台鼠标弹起 (窗口句柄, 弹起X, 弹起Y, 鼠标键)
    .如果 (结果 ＞ 0)
        调试输出 ("前台驱动鼠标弹起成功")
        调试输出 ("拖拽操作完成")
    .否则
        调试输出 ("前台驱动鼠标弹起失败")
    .如果结束
    
    返回 (结果)
```
### HD驱动_前台鼠标移动弹起 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_前台鼠标移动弹起 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_前台按键
### 描述
```
前台驱动键盘(按下并弹起)
```
### 原型
```
__int64 __stdcall HCHD_KbPress(__int32 virtualKeyCode,__int32 mis);
```
### 参数
```
__int32 virtualKeyCode - 虚拟键码
__int32 mis - 按下和弹起之间的毫秒差
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_前台按键 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_前台按键 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_前台按键按下
### 描述
```
前台驱动键盘(按下某键)
```
### 原型
```
__int64 __stdcall HCHD_KbDown(__int32 virtualKeyCode);
```
### 参数
```
__int32 virtualKeyCode - 虚拟键码
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_前台按键按下 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_前台按键按下 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_前台按键弹起
### 描述
```
前台驱动键盘(弹起某键)
```
### 原型
```
__int64 __stdcall HCHD_KbUp(__int32 virtualKeyCode);
```
### 参数
```
__int32 virtualKeyCode - 虚拟键码
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_前台按键弹起 - 基础示例
```
.版本 2

.子程序 测试VNC左键弹起, 逻辑型, 公开
    .局部变量 窗口序号, 整数型
    .局部变量 结果, 逻辑型
    
    窗口序号 ＝ 1
    
    调试输出 ("准备执行VNC左键弹起")
    
    ' 执行VNC左键弹起
    结果 ＝ HDVNC_左键弹起 (窗口序号)
    .如果 (结果 ＝ 真)
        调试输出 ("VNC左键弹起成功")
        调试输出 ("拖拽操作完成")
    .否则
        调试输出 ("VNC左键弹起失败")
    .如果结束
    
    返回 (结果)
```
### HD驱动_前台按键弹起 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_前台按键弹起 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_驱动读写
### 描述
```
驱动读写
```
### 原型
```
__int64 __stdcall HCHD_RW(__int32 pid,__int64 targetAddress,__int64 bufferAddress,__int32 bufferOfBytes,__int32 rwType);
```
### 参数
```
__int32 pid - 进程ID
__int64 targetAddress - 目标地址
__int64 bufferAddress - 数据缓冲区指针
__int32 bufferOfBytes - 数据缓冲区大小,
__int32 rwType - 读写类型[0=读内存;1=写内存;2=强写内存]
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_驱动读写 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_驱动读写 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_开始读写
### 描述
```
驱动读写Ex(开始批读写)与HCHD_EndRWEx成对出现适合快速遍历(百万级别读写单线程)
```
### 原型
```
__int64 __stdcall HCHD_BeginRWEx(__int32 pid);
```
### 参数
```
__int32 pid - 进程ID
```
### 返回值
```
查看返回值表
```
### 注意事项
```
适合快速遍历
```
### HD驱动_开始读写 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_开始读写 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_驱动读写Ex
### 描述
```
驱动读写Ex(批量读写)(百万级别读写单线程)
```
### 原型
```
__int64 __stdcall HCHD_RWEx(__int64 targetAddress,__int64 bufferAddress,__int32 bufferOfBytes,__int32 rwType);
```
### 参数
```
__int64 targetAddress - 目标地址
__int64 bufferAddress - 数据缓冲区指针
__int32 bufferOfBytes - 数据缓冲区大小,
__int32 rwType - 读写类型[0=读内存;1=写内存;2=强写内存]
```
### 返回值
```
查看返回值表
```
### 注意事项
```
先调用HCHD_BeginRWEx然后中间调用该接口HCHD_RWEx最后调用HCHD_EndRWEx用于释放环境
```
### HD驱动_驱动读写Ex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_驱动读写Ex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_结束读写
### 描述
```
驱动读写Ex(结束批读写)与HCHD_BeginRWEx成对出现适合快速遍历(百万级别读写单线程)
```
### 原型
```
__int64 __stdcall HCHD_EndRWEx();
```
### 返回值
```
查看返回值表
```
### 注意事项
```
适合快速遍历
```
### HD驱动_结束读写 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_结束读写 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_地址是否可读
### 描述
```
检查地址是否可读
```
### 原型
```
__int64 __stdcall HCHD_AddrIsRead(__int32 pid,__int64 addr,__int32 size);
```
### 参数
```
__int32 pid - 进程ID指定为0表示初始化HD快速读写遍历(适合)
__int64 addr - 需要测试的地址
__int32 size - 地址所涉及到的字节大小(4字节或者8字节),不能为其他字节数
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_地址是否可读 - 基础示例
```
.版本 2

.子程序 _读取ANSI文本示例
    .局部变量 读取文本, 文本型
    .局部变量 窗口序号, 整数型
    .局部变量 文本地址, 长整数型
    .局部变量 文本长度, 整数型
    
    窗口序号 = 0
    文本地址 = 16777216  ' 0x1000000
    文本长度 = 50
    
    读取文本 = HD内存_读地址文本Annsi (窗口序号, 文本地址, 文本长度)
    
    .如果 (读取文本 ≠ "")
        调试输出 ("读取到ANSI文本: " + 读取文本)
        
        ' 处理读取到的文本
        .如果 (寻找文本 (读取文本, "游戏", , 假) > 0)
            调试输出 ("文本中包含"游戏"关键字")
        .如果结束
    .否则
        调试输出 ("未读取到有效文本")
    .如果结束
```
### HD驱动_地址是否可读 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_地址是否可读 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_进程保护
### 描述
```
进程保护
```
### 原型
```
__int64 __stdcall HCHD_PP(__int32 pid,BOOL bOpen);
```
### 参数
```
__int32 pid - 进程ID
bool bOpen - 是否开启[1=开启保护;0=关闭保护]
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_进程保护 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_进程保护 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_进程隐藏
### 描述
```
开启进程隐藏
```
### 原型
```
__int64 __stdcall HCHD_PHide(__int32 pid);
```
### 参数
```
__int32 pid - 进程ID
```
### 返回值
```
查看返回值表
```
### 注意事项
```
一次性只能隐藏一个,如果需要隐藏第二个,先把之前的给显示了
```
### HD驱动_进程隐藏 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_进程隐藏 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCHD_PHideEx
### 描述
```
开启进程隐藏(加强版本)无法恢复
```
### 原型
```
__int64 __stdcall HCHD_PHideEx(__int32 pid);
```
### 参数
```
__int32 pid - 进程ID
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.隐藏后关闭进程不会蓝屏
2.隐藏后该接口无法恢复显示,其实也没必要恢复显示
```
### HCHD_PHideEx - 基础示例
```
.版本 2

.子程序 _轨迹移动扩展
    .局部变量 移动结果, 逻辑型
    
    移动结果 = HD键鼠_轨迹移动Ex (0, 500, 300, 1, 50)
    调试输出 ("轨迹移动成功")
```
### HCHD_PHideEx - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCHD_PHideEx - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_进程显示
### 描述
```
进程显示
```
### 原型
```
__int64 __stdcall HCHD_PShow(__int32 pid);
```
### 参数
```
__int32 pid - 进程ID
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_进程显示 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_进程显示 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD_进程杀死
### 描述
```
进程杀死
```
### 原型
```
__int64 __stdcall HCHD_PPKill(char* processName,__int32 pid);
```
### 参数
```
char* processName - 进程名把当前所有相同进程名全部杀掉
__int32 pid - 进程PID指定了PID进程名就失效
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD_进程杀死 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD_进程杀死 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_申请内存
### 描述
```
驱动申请内存
```
### 原型
```
__int64 __stdcall HCHD_MemoryAllocate(__int32 pid,__int64 memorySize,__int32 memoryProtect,BOOL bHighAddress,__int64 pOutBuffer);
```
### 参数
```
__int32 pid - 进程ID
__int64 memorySize - 申请大小
__int32 memoryProtect - 内存保护属性例如
bool bHighAddress - 是否申请高位内存如果申请大小超过4字节存储的值就属于高位内存一般为假就行
__int64 pOutBuffer - 缓冲区指针(存申请返回的地址)
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_申请内存 - 基础示例
```
.版本 2

.子程序 _写表达式示例
    .局部变量 写入结果, 逻辑型
    .局部变量 窗口序号, 整数型
    .局部变量 指针表达式, 文本型
    .局部变量 新值, 长整数型
    
    窗口序号 = 0
    指针表达式 = "[[0x500000+0x18]+0x0C]+0x14"
    新值 = 12345
    
    写入结果 = HD内存_写表达式 (窗口序号, 指针表达式, 4, 新值)
    
    .如果 (写入结果 = 真)
        调试输出 ("多级指针写入成功")
        
        ' 读取验证
        .局部变量 验证值, 长整数型
        验证值 = HD内存_读表达式 (窗口序号, 指针表达式, 4)
        调试输出 ("验证读取值: " + 到文本 (验证值))
    .否则
        调试输出 ("多级指针写入失败")
    .如果结束
```
### HD驱动_申请内存 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_申请内存 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_申请内存Ex
### 描述
```
驱动申请内存(扩展版本)
```
### 原型
```
__int64 __stdcall HCHD_MemoryAllocateEx(__int32 pid,__int64 memoryAddr,__int64 memorySize,__int32 memoryProtect,BOOL bHighAddress,__int64 pOutBuffer);
```
### 参数
```
__int32 pid - 进程ID
__int64 memoryAddr - 指定的内存地址或者为NULL(0)
__int64 memorySize - 申请大小
__int32 memoryProtect - 内存保护属性
bool bHighAddress - 是否申请高位内存如果申请大小超过4字节存储的值就属于高位内存一般为假就行
__int64 pOutBuffer - 缓冲区指针(存申请返回的地址)
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_申请内存Ex - 基础示例
```
.版本 2

.子程序 _申请内存
    .局部变量 内存地址, 长整数型
    
    内存地址 = HD内存_申请内存 (0, 0, 4096, 4096, 64)
    调试输出 ("内存申请成功，地址: " + 到文本 (内存地址))
```
### HD驱动_申请内存Ex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_申请内存Ex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_内存释放
### 描述
```
驱动内存释放
```
### 原型
```
__int64 __stdcall HCHD_MemoryFree(__int32 pid,__int64 memoryAddress);
```
### 参数
```
__int32 pid - 进程ID
__int64 memoryAddress - 需要释放的内存地址
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_内存释放 - 基础示例
```
.版本 2

.子程序 _释放内存
    .局部变量 释放结果, 逻辑型
    
    释放结果 = HD内存_释放内存 (0, 8388608, 4096, 32768)
    调试输出 ("内存释放成功")
```
### HD驱动_内存释放 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_内存释放 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_修改内存保护
### 描述
```
驱动修改内存保护属性
```
### 原型
```
__int64 __stdcall HCHD_MemoryProtect(__int32 pid,__int64 memoryAddress,__int64 memoryOfBytes,__int32 newProtect);
```
### 参数
```
__int32 pid - 进程ID
__int64 memoryAddress - 内存地址
__int64 memoryOfBytes - 内存大小
__int32 newProtect - 新保护值
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_修改内存保护 - 基础示例
```
.版本 2

.子程序 _特征码搜索示例
    .局部变量 找到地址, 长整数型
    .局部变量 窗口序号, 整数型
    .局部变量 特征码, 文本型
    .局部变量 起始地址, 长整数型
    .局部变量 结束地址, 长整数型
    
    窗口序号 = 0
    特征码 = "8B 0D ?? ?? ?? ?? 85 C9 74 ??"  ' 特征码模式
    起始地址 = 4194304  ' 0x400000
    结束地址 = 134217728  ' 0x8000000
    
    找到地址 = HD内存_特征码 (窗口序号, 起始地址, 结束地址, 特征码)
    
    .如果 (找到地址 > 0)
        调试输出 ("找到特征码地址: 0x" + 到十六进制 (找到地址))
    .否则
        调试输出 ("未找到特征码")
    .如果结束
```
### HD驱动_修改内存保护 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_修改内存保护 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_内存隐藏
### 描述
```
驱动内存隐藏
```
### 原型
```
__int64 __stdcall HCHD_MemoryHide(__int32 pid,__int64 memoryAddress,__int64 memoryOfBytes);
```
### 参数
```
__int32 pid - 进程ID
__int64 memoryAddress - 内存地址
__int64 memoryOfBytes - 内存大小
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_内存隐藏 - 基础示例
```
.子程序 _测试内存地址模板匹配
    .局部变量 图片数据1, 字节集
    .局部变量 图片数据2, 字节集
    .局部变量 图片数据3, 字节集
    .局部变量 内存地址1, 长整数型
    .局部变量 内存地址2, 长整数型
    .局部变量 内存地址3, 长整数型
    .局部变量 地址集合字符串, 文本型
    .局部变量 匹配结果, 整数型
    .局部变量 X坐标, 整数型
    .局部变量 Y坐标, 整数型
    .局部变量 匹配数组, HD_2个坐标, 数组
    
    ' 第一步：加载图片到内存
    图片数据1 = 读入文件 ("模板1.bmp")
    图片数据2 = 读入文件 ("模板2.bmp") 
    图片数据3 = 读入文件 ("模板3.bmp")
    
    .如果 (取字节集长度 (图片数据1) = 0 或者 取字节集长度 (图片数据2) = 0 或者 取字节集长度 (图片数据3) = 0)
        调试输出 ("图片文件加载失败")
        返回 (假)
    .如果结束
    
    ' 第二步：获取内存地址
    内存地址1 = 取字节集数据地址 (图片数据1)
    内存地址2 = 取字节集数据地址 (图片数据2)
    内存地址3 = 取字节集数据地址 (图片数据3)
    
    ' 第三步：构建地址集合字符串
    地址集合字符串 = 到文本 (内存地址1) + "," + 到文本 (取字节集长度 (图片数据1)) + "|" + 到文本 (内存地址2) + "," + 到文本 (取字节集长度 (图片数据2)) + "|" + 到文本 (内存地址3) + "," + 到文本 (取字节集长度 (图片数据3))
    
    调试输出 ("内存地址集合:", 地址集合字符串)
    
    ' 第四步：执行内存模板匹配
    匹配结果 = HD智能识图_Tem找图来源内存 (0, 地址集合字符串, 0.85, 5, 真, 真, 假, X坐标, Y坐标, 匹配数组)
    
    .如果 (匹配结果 ≥ 0)
        调试输出 ("内存模板匹配成功！")
        调试输出 ("匹配模板序号:", 匹配结果)
        调试输出 ("最优坐标: (", X坐标, ",", Y坐标, ")")
        调试输出 ("找到", 取数组成员数 (匹配数组), "个匹配结果")
        
        .局部变量 i, 整数型
        .计次循环首 (取数组成员数 (匹配数组), i)
            调试输出 ("  结果", i, ": 位置(", (匹配数组 [i].x1 + 匹配数组 [i].x2) ÷ 2, ",", (匹配数组 [i].y1 + 匹配数组 [i].y2) ÷ 2, ") 相似度:", 匹配数组 [i].sim)
        .计次循环尾 ()
    .否则
        调试输出 ("内存模板匹配失败")
    .如果结束
```
### HD驱动_内存隐藏 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_内存隐藏 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_内存查询
### 描述
```
驱动内存查询
```
### 原型
```
__int64 __stdcall HCHD_MemoryQuery(__int32 pid,__int64 memoryAddress,PVOIDpOutBuffer);
```
### 参数
```
__int32 pid - 进程ID
__int64 memoryAddress - 内存地址
 pOutBuffer - 缓冲区指针[这里固定使用的是64位的MEMORY_BASIC_INFORMATION结构体,结构体大(48字节)]结构体
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_内存查询 - 基础示例
```
.版本 2

.子程序 _双精度转换示例
    .局部变量 长整数表示, 长整数型
    .局部变量 双精度值, 双精度小数型
    
    长整数表示 = 4607182418800017408  ' 1.0的双精度表示
    双精度值 = HD内存_双浮点长整数转双浮点数 (长整数表示)
    调试输出 ("长整数转双精度浮点数: " + 到文本 (双精度值))
```
### HD驱动_内存查询 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_内存查询 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_特征码查找地址
### 描述
```
驱动通过特征码查找地址
```
### 原型
```
__int64 __stdcall HCHD_MemoryFindCode(__int32 pid,__int64 address,__int64 siginCode,__int32 siginCodeSize,__int32 iProtect,__int64 outBuffer);
```
### 参数
```
__int32 pid - 进程ID
__int64 address - 起始搜索地址
__int64 siginCode - 特征码(二进制缓冲区不是字符串)
__int32 siginCodeSize - 特征码长度(字节单位),
__int32 iProtect - 要搜索的内存保护属性
__int64 outBuffer - 缓冲区(存地址)
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_特征码查找地址 - 基础示例
```
.版本 2

.子程序 _读表达式字节流示例
    .局部变量 字节数据, 字节集
    
    字节数据 = HD内存_读表达式字节流 (0, "game.exe+0x123456+0x60", 16)
    调试输出 ("读取字节数: " + 到文本 (取字节集长度 (字节数据)))
```
### HD驱动_特征码查找地址 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_特征码查找地址 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_获取主模块地址
### 描述
```
驱动获取主模块EXE的地址
```
### 原型
```
__int64 __stdcall HCHD_GetMainModuleBase(__int32 pid,__int64 outBuffer);
```
### 参数
```
__int32 pid - 进程ID
__int64 outBuffer - 缓冲区指针(存地址)
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_获取主模块地址 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_获取主模块地址 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_获取模块地址
### 描述
```
驱动获取指定模块的地址
```
### 原型
```
__int64 __stdcall HCHD_GetModuleBase(__int32 pid,char* moduleName,__int64 outBuffer);
```
### 参数
```
__int32 pid - 进程ID
char* moduleName - 模块名(Ascii字符串)
__int64 outBuffer - 缓冲区指针(存地址)
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_获取模块地址 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_获取模块地址 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_获取模块函数地址
### 描述
```
驱动获取指定模块的指定的函数地址
```
### 原型
```
__int64 __stdcall HCHD_GetModuleCallAddr(__int32 pid,char* moduleName,char* callName,__int64 outBuffer);
```
### 参数
```
__int32 pid - 进程ID
char* moduleName - 模块名(Ascii字符串)
char* callName - 函数名字(Ascii字符串)
__int64 outBuffer - 缓冲区指针(存地址)
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_获取模块函数地址 - 基础示例
```
.版本 2

.子程序 _读取浮点数示例
    .局部变量 浮点文本, 文本型
    .局部变量 窗口序号, 整数型
    .局部变量 浮点地址, 长整数型
    .局部变量 浮点值, 小数型
    
    窗口序号 = 0
    浮点地址 = 16777216  ' 0x1000000
    
    ' 读取单精度浮点数
    浮点文本 = HD内存_读地址浮点数 (窗口序号, 浮点地址, 4)
    
    .如果 (浮点文本 ≠ "")
        浮点值 = 到数值 (浮点文本)
        调试输出 ("读取到单精度浮点数: " + 浮点文本)
        
        ' 判断浮点数值范围
        .如果 (浮点值 > 0.0)
            调试输出 ("浮点数为正值")
        .否则
            调试输出 ("浮点数为负值或零")
        .如果结束
    .否则
        调试输出 ("读取浮点数失败")
    .如果结束
```
### HD驱动_获取模块函数地址 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_获取模块函数地址 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_修改机器码
### 描述
```
驱动修改机器码
```
### 原型
```
__int64 __stdcall HCHD_ChangeMachineKey(__int32 type);
```
### 参数
```
 参数 - 类型0=全部开启1=注册表2=硬盘序列号3=网卡序列号4=本地文件特征5=微端设备序列号6=网络代理设备序列号7=图形处理器(GPU-GUID)8=分区序列号9=固态硬盘序列号10=主板BIOS序列号11=硬盘数据卷序列号(静态)12=硬盘数据卷序列号(动态)
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_修改机器码 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_修改机器码 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_反截图
### 描述
```
驱动内核反截图
```
### 原型
```
__int64 __stdcall HCHD_NTNCaptureScreen(__int64 hWnd,BOOL Enable);
```
### 参数
```
__int64 hWnd - 窗口句柄
bool Enable - 是否开启
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_反截图 - 基础示例
```
.版本 2

.子程序 测试关闭VNC截图, 逻辑型, 公开
    .局部变量 窗口序号, 整数型
    .局部变量 结果, 逻辑型
    
    窗口序号 ＝ 1
    
    调试输出 ("准备关闭VNC截图功能")
    调试输出 ("窗口序号：", 窗口序号)
    
    ' 关闭VNC截图功能
    结果 ＝ HDVNC_关闭截图 (窗口序号)
    .如果 (结果 ＝ 真)
        调试输出 ("VNC截图功能已关闭")
        调试输出 ("截图线程已结束")
    .否则
        调试输出 ("关闭VNC截图功能失败")
    .如果结束
    
    返回 (结果)
```
### HD驱动_反截图 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_反截图 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_远线程执行CALL
### 描述
```
驱动内存远线程执行函数
```
### 原型
```
__int64 __stdcall HCHD_NTThreadRunCall(__int32 pid,__int64 callAddress);
```
### 参数
```
__int32 pid - 进程PID
__int64 callAddress - CALL地址
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_远线程执行CALL - 基础示例
```
.版本 2

.子程序 64位CALL调用示例
    .局部变量 窗口序号, 整数型
    .局部变量 函数地址, 长整数型
    .局部变量 调用结果, 长整数型
    .局部变量 参数1, 长整数型
    .局部变量 参数2, 长整数型
    .局部变量 参数3, 长整数型
    
    窗口序号 ＝ 1
    函数地址 ＝ 4548350032  ' 目标函数地址
    参数1 ＝ 100
    参数2 ＝ 200
    参数3 ＝ 300
    
    ' 调用64位函数（3个参数）
    调用结果 ＝ HC_CALL (窗口序号, 函数地址, 参数1, 参数2, 参数3, 0, 0, 0, 0, 0)
    
    .如果 (调用结果 ≠ 0)
        调试输出 ("64位CALL调用成功")
        调试输出 ("返回值：" ＋ 到文本 (调用结果))
        
        ' 根据返回值进行处理
        .如果 (调用结果 ＝ 1)
            调试输出 ("函数执行成功")
        .否则 .如果 (调用结果 ＝ -1)
            调试输出 ("函数执行出现错误")
        .否则
            调试输出 ("函数返回特殊值：" ＋ 到文本 (调用结果))
        .如果结束
        
    .否则
        调试输出 ("64位CALL调用失败")
    .如果结束
```
### HD驱动_远线程执行CALL - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_远线程执行CALL - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_清除注入缓存
### 描述
```
驱动清除注入缓存(全局插件缓存,DLL缓存)
```
### 原型
```
__int64 __stdcall HCHD_ClearInject();
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_清除注入缓存 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_清除注入缓存 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_进程提权
### 描述
```
进程提权
```
### 原型
```
__int64 __stdcall HCHD_PcrocessRoot(__int32 pid);
```
### 参数
```
__int32 pid - 进程PID(内部会通过PID获取进程句柄)
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD驱动_进程提权 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_进程提权 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCHD_HandleRoot
### 描述
```
进程提权
```
### 原型
```
__int64 __stdcall HCHD_HandleRoot(__int64 handle);
```
### 参数
```
__int64 handle - 句柄
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HCHD_HandleRoot - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCHD_HandleRoot - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD驱动_设置鼠标轨迹
### 描述
```
设置驱动鼠标移动轨迹类型
```
### 原型
```
__int64 __int64 __stdcall  HCHD_SetMMTrackType(__int32 type);
```
### 参数
```
__int32 type - 轨迹类型 -1或0 表示无轨迹  1 表示随机轨迹 2表示直线轨迹 3表示直线波动轨迹(过检测强)  具体的轨迹效果可以参考:后台键鼠的轨迹
```
### 返回值
```
查看返回值表
返回之前的轨迹类型
```
### 注意事项
```
无
```
### HD驱动_设置鼠标轨迹 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD驱动_设置鼠标轨迹 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
