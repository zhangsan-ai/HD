# 🛰️ 通讯环境模块(Env)
## 📌 函数: HD环境_初始化
### 描述
```
HD插件环境加载(初始化中控环境)
```
### 原型
```
__int64 __stdcall HCEnv_Init(__int32 timeOut=10000);
```
### 参数
```
__int32 timeOut - 通讯超时时间(毫秒),默认就行
```
### 返回值
```
查看返回值表
返回值为0是正确的,表示当前中控进程窗口序号为0！！！
目标进程窗口序号大于等于1,自己管理,0序号内置为中控进程窗口序号
```
### 注意事项
```
中控初始化开始就要调用,仅仅一次
```
### HD环境_初始化 - 基础示例
```
.版本 2

.子程序 _HD环境初始化
    .局部变量 初始化结果, 逻辑型
    
    初始化结果 = HD环境_初始化 ()
    
    .如果 (初始化结果 = 真)
        调试输出 ("HD环境初始化成功")
    .否则
        调试输出 ("HD环境初始化失败")
    .如果结束
```
### HD环境_初始化 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_初始化 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_初始化Ex
### 描述
```
HD插件环境加载(初始化中控环境)(扩展版本)最新版本一般不用了
```
### 原型
```
__int64 __stdcall HCEnv_InitEx(__int32 通讯超时毫秒=10000,__int32 通讯检测间隔毫秒=20,__int32 回调响应毫秒=5);
```
### 参数
```
__int32 timeOut(通讯超时毫秒) - 通讯超时时间(毫秒),默认就行
__int32 通讯检测间隔毫秒 - 默认就行,越小响应越快,CPU占用了越高(可以忽视最新版本不需要考虑这个问题了)
__int32 回调响应毫秒 - 默认就行,越小响应越快,CPU占用了越高
```
### 返回值
```
查看返回值表
返回值为0是正确的,表示当前中控进程窗口序号为0！！！
目标进程窗口序号大于等于1,自己管理,0序号内置为中控进程窗口序号
```
### 注意事项
```
中控初始化开始就要调用,仅仅一次
```
### HD环境_初始化Ex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_初始化Ex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_加载窗口
### 描述
```
HD插件环境加载
```
### 原型
```
__int64 __stdcall HCEnv_Load(__int32 窗口序号,__int32 目标进程PID,__int32 游戏类型=0);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int32 目标进程PID - 目标进程PID
__int32 游戏类型 - 内置了游戏接口(每个游戏类型值不同),可以在工具上查看对应的值
```
### 返回值
```
查看返回值表
```
### 注意事项
```
调用这个接口需要先调用环境初始化模块中的初始化接口
每次打开进程后都要调用
```
### HD环境_加载窗口 - 基础示例
```
.版本 2

.子程序 _加载窗口
    .局部变量 加载结果, 长整数型
    .局部变量 窗口序号, 整数型
    
    窗口序号 = 0
    加载结果 = HD环境_加载窗口 (窗口序号)
    
    .如果 (加载结果 > 0)
        调试输出 ("窗口" + 到文本 (窗口序号) + "加载成功")
    .否则
        调试输出 ("窗口加载失败")
    .如果结束
```
### HD环境_加载窗口 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_加载窗口 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_加载窗口Ex
### 描述
```
HD插件环境加载(扩展版本),涉及到回调
```
### 原型
```
__int64 __stdcall HCEnv_LoadEx(__int32 窗口序号,__int32 目标进程PID,__int32 游戏类型=0,BOOL 是否开启接受线程=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int32 目标进程PID - 目标进程PID
__int32 游戏类型 - 内置了游戏接口(每个游戏类型值不同),可以在工具上查看对应的值
bool 是否开启接受线程 - 如果需要开启跨进程回调(如
```
### 返回值
```
查看返回值表
```
### 注意事项
```
调用这个接口需要先调用环境初始化模块中的初始化接口
每次打开进程后都要调用
```
### HD环境_加载窗口Ex - 基础示例
```
.子程序 _测试Unicode矩形找图
    .局部变量 Unicode名称, 字节集
    .局部变量 矩形结果, HD_2个坐标, 数组
    
    Unicode名称 = 到字节集 ("界面元素.bmp|控件.bmp", #编码_UTF16_LE, 真)
    
    .如果 (HD智能识图_找图ExW (0, Unicode名称, 0.85, 真, 假, 矩形结果))
        调试输出 ("Unicode矩形找图成功")
        ' 处理矩形结果...
    .如果结束
```
### HD环境_加载窗口Ex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_加载窗口Ex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_卸载窗口
### 描述
```
HD插件环境卸载
```
### 原型
```
__int64 __stdcall HCEnv_UnLoad(__int32 窗口序号);
```
### 参数
```
__int32 窗口序号 - 窗口序号（从1开始）
```
### 返回值
```
查看返回值表
```
### 注意事项
```
调用这个接口需要先调用环境初始化模块中的初始化接口
进程关闭一定要记得卸载窗口序号对应的窗口环境,以便于下次窗口序号使用
1.没安装过插件的都不算重连窗口全部当新窗口处理
2.安装过插件的不管卸载环境还是崩溃或者重启窗口都可以重连窗口一个序号只能绑定到一个窗口操作
```
### HD环境_卸载窗口 - 基础示例
```
.版本 2

.子程序 _卸载窗口
    .局部变量 卸载结果, 逻辑型
    .局部变量 窗口序号, 整数型
    
    窗口序号 = 0
    卸载结果 = HD环境_卸载窗口 (窗口序号)
    
    .如果 (卸载结果 = 真)
        调试输出 ("窗口" + 到文本 (窗口序号) + "卸载成功")
    .否则
        调试输出 ("窗口卸载失败")
    .如果结束
```
### HD环境_卸载窗口 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_卸载窗口 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_卸载窗口Ex
### 描述
```
HD插件环境卸载(扩展版本)
```
### 原型
```
__int64 __stdcall HCEnv_UnLoadEx(__int32 窗口序号,BOOL bRecon=TRUE);
```
### 参数
```
__int32 窗口序号 - 窗口序号（从1开始）
bool bRecon - 是否还需要重连默认是需要重连
```
### 返回值
```
查看返回值表
```
### 注意事项
```
调用这个接口需要先调用环境初始化模块中的初始化接口
进程关闭一定要记得卸载窗口序号对应的窗口环境,以便于下次窗口序号使用
1.没安装过插件的都不算重连窗口全部当新窗口处理
2.安装过插件的不管卸载环境还是崩溃或者重启窗口都可以重连窗口一个序号只能绑定到一个窗口操作
```
### HD环境_卸载窗口Ex - 基础示例
```
.版本 2

.子程序 _特征码搜索Ex示例
    .局部变量 找到地址, 长整数型
    .局部变量 窗口序号, 整数型
    .局部变量 模块名, 文本型
    .局部变量 特征码, 文本型
    .局部变量 偏移量, 整数型
    
    窗口序号 = 0
    模块名 = ""  ' 主模块
    特征码 = "A1 ?? ?? ?? ?? 8B ?? ?? ?? ?? ?? 85 C0"
    偏移量 = 5  ' 找到后向后偏移5字节
    
    找到地址 = HD内存_特征码Ex (窗口序号, 模块名, 特征码, 偏移量, 0)
    
    .如果 (找到地址 > 0)
        调试输出 ("特征码Ex找到地址: 0x" + 到十六进制 (找到地址))
        ' 可以继续读取该地址的数据
    .否则
        调试输出 ("特征码Ex搜索失败")
    .如果结束
```
### HD环境_卸载窗口Ex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_卸载窗口Ex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HDEnv_GetWinExIndex
### 描述
```
获取副窗口序号
```
### 原型
```
__int64 __stdcall HDEnv_GetWinExIndex(__int32 winIndex);
```
### 参数
```
__int32 winIndex - 传递窗口序号返回一个与当前指定的窗口序号的一个副窗口序号
```
### 返回值
```
查看返回值表
```
### 注意事项
```
这个副窗口序号可以用于登录器的绑定和操作,相当于窗口序号的一个助手,做一些额外的事情相当于一个窗口序号可以操作2个进程如:窗口序号1那么他返回的窗口扩展序号就是1+31也就是32序号
```
### HDEnv_GetWinExIndex - 基础示例
```
.版本 2

.子程序 _获取副窗口序号
    .局部变量 副窗口序号, 长整数型
    .局部变量 主窗口序号, 整数型
    
    主窗口序号 = 0
    副窗口序号 = HD环境_获取副窗口序号 (主窗口序号)
    
    调试输出 ("主窗口" + 到文本 (主窗口序号) + "的副窗口序号: " + 到文本 (副窗口序号))
```
### HDEnv_GetWinExIndex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HDEnv_GetWinExIndex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HDEnv_GetGlobalWinExIndex
### 描述
```
获取全局副窗口序号,这是一个全局的序号
```
### 原型
```
__int64 __stdcall HDEnv_GetGlobalWinExIndex();
```
### 返回值
```
查看返回值表
```
### 注意事项
```
一个中控仅有一个计算方式:0+31也就是这个全局序号为31序号从0开始用途:给当前中控分配一个助手,来控制一个进程来辅助中控做一些事情
```
### HDEnv_GetGlobalWinExIndex - 基础示例
```
.版本 2

.子程序 _获取全局副窗口序号
    .局部变量 全局副窗口序号, 长整数型
    
    全局副窗口序号 = HD环境_全局副窗口序号 ()
    调试输出 ("全局副窗口序号: " + 到文本 (全局副窗口序号))
```
### HDEnv_GetGlobalWinExIndex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HDEnv_GetGlobalWinExIndex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_附加心跳
### 描述
```
给中控附加心跳
```
### 原型
```
__int64 __stdcall HCEnv_AttachHeart(__int32 type,__int64 funCallbackAddr,__int32 timeOutNor=10000,__int32 timeOut=10000);
```
### 参数
```
__int32 给中控附加心跳type - 0->正常心跳(内部触发心跳回调+排序回调)1->通讯线程2->主线程3->卡屏6->1+2+3如果需要检测主线程心跳是否卡住,请记得先HOOK主线程【HC_HookMaint hread()】接口timeOutNorL
```
### 返回值
```
1正常处理返回0禁止当前窗口序号的心跳(永久无法恢复除非重启中控一般用于测试调试)
返回值:
查看返回值表
```
### 注意事项
```
检测主线程心跳
如果需要检测主线程心跳是否卡住,请记得先HOOK主线程接口HC_HookMaint hread
设置心跳回调函数类型
typedef__int32 (* HeartFunType)(__int32 窗口索引,__int32 type);回调函数返回值:0不重置之前的记录1重置之前的记录(一般重新开启新进程会设置为1)
\n0.正常心跳进程存在的情况下会触发\n1.通讯崩溃/关闭等等原因导致进程不存在->重启窗口\n2.主线程崩溃/关闭/未响应/目标进程卡死原因导致进程不存在/存在->强制关闭->重启窗口设置挂接主线程\n2.1.附加心跳的时候可以检查主线程的状态(游戏/目标)\n2.2.后面的内存操作可以主线程调用\n2.3.注意:附加心跳的时候设置的检查时间一定要大于安装插件到挂接主线程的时间\n3.卡屏崩溃/关闭/区域图像卡死了原因导致进程不存在/存在->强制关闭->重启窗口设置屏幕检查范围\n6.1+2+3
```
### HD环境_附加心跳 - 基础示例
```
' C++接口定义：typedef __int32(__stdcall *HeartFunType)(__int32 窗口索引, __int32 type);
.子程序 心跳回调, 整数型, 公开
    .参数 窗口索引, 整数型
    .参数 type, 整数型
    ' type = 1：窗口消失不存在了，建议卸载环境
    ' type = 2：窗口存在但可能卡住，建议重启或处理
    ' type = 3：窗口卡屏检测触发
    ' 返回值：1表示正常处理，0表示不重置记录
```
### HD环境_附加心跳 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_附加心跳 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCEnv_SetWindowsSortInfo
### 描述
```
设置窗口排序信息
```
### 原型
```
__int64 __stdcall HCEnv_SetWindowsSortInfo(__int32 x,__int32 y,__int32 offsetx,__int32 offsety,__int32 cols,__int64 funCallbackAddr);
```
### 参数
```
__int32 x - 屏幕左上角X开始x
```
### 返回值
```
查看返回值表
```
### HCEnv_SetWindowsSortInfo - 基础示例
```
.版本 2

.子程序 _设置回调响应间隔
    .局部变量 设置结果, 逻辑型
    .局部变量 间隔时间, 整数型
    
    间隔时间 = 100  ' 设置为100毫秒
    设置结果 = HD环境_设置回调响应间隔 (间隔时间)
    
    .如果 (设置结果 = 真)
        调试输出 ("回调响应间隔设置成功: " + 到文本 (间隔时间) + "毫秒")
    .否则
        调试输出 ("回调响应间隔设置失败")
    .如果结束
```
### HCEnv_SetWindowsSortInfo - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCEnv_SetWindowsSortInfo - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_设置卡屏检查信息
### 描述
```
当我们心跳检测指定了3或者6需要设置卡屏范围和卡屏检测次数当大于这个次数就调用回调
```
### 原型
```
__int64 __stdcall HCEnv_SetScreenCheckHeart(__int32 x,__int32 y,__int32 w,__int32 h,__int32 最大次数,__int32 截屏前后间隔时间=1000);
```
### 参数
```
__int32 x - 客户端x
__int32 y - 客户端y
__int32 w - 区域宽度
__int32 h - 区域高度
__int32 最大次数 - 当到达这个次数就会触发回调
__int32 截屏前后间隔时间 - 前后时间间隔用来比较图像是否卡主
```
### 返回值
```
查看返回值表
```
### HD环境_设置卡屏检查信息 - 基础示例
```
.版本 2

.子程序 _设置卡屏检测
    .局部变量 设置结果, 逻辑型
    
    ' 设置检测区域为(0,0)到(200,200)，检测30秒
    设置结果 = HD环境_设置卡屏检查信息 (0, 0, 200, 200, 30)
    
    .如果 (设置结果 = 真)
        调试输出 ("卡屏检测区域设置成功")
        调试输出 ("检测区域: (0,0) - (200,200)")
        调试输出 ("检测时长: 30秒")
    .否则
        调试输出 ("卡屏检测设置失败")
    .如果结束
```
### HD环境_设置卡屏检查信息 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_设置卡屏检查信息 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_脱离心跳
### 描述
```
脱离中控附加的心跳检测
```
### 原型
```
__int64 __stdcall HCEnv_DetachHeart();
```
### 返回值
```
查看返回值表
```
### 注意事项
```
脱离会堵塞直到脱离成功一般中控进程结果关闭前调用
```
### HD环境_脱离心跳 - 基础示例
```
.版本 2

.子程序 _解绑键鼠操作
    .局部变量 解绑结果, 逻辑型
    .局部变量 窗口序号, 整数型
    
    窗口序号 = 0
    解绑结果 = HD键鼠_解绑 (窗口序号)
    
    .如果 (解绑结果 = 真)
        调试输出 ("窗口" + 到文本 (窗口序号) + "键鼠解绑成功")
    .否则
        调试输出 ("键鼠解绑失败")
    .如果结束
```
### HD环境_脱离心跳 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_脱离心跳 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_调试模式
### 描述
```
设置导入接口为调试模式
```
### 原型
```
__int64 __stdcall HCEnv_Debug(BOOL 是否调试=FALSE);
```
### 参数
```
bool 是否调试 - 当使用【HDDebug.dll】导入接口的时候就需要调用这个设置为调试模式(否者插件可能安装不成功)然后方可继续后面的一系列操作
```
### 返回值
```
查看返回值表
```
### 注意事项
```
中控初始化开始就可以调用,仅仅一次
发布版本不需要调用此接口,默认为发布版本
```
### HD环境_调试模式 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_调试模式 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_开启文件提示
### 描述
```
设置是否打开文件提示窗口
```
### 原型
```
__int64 __stdcall HCEnv_MsgFile(BOOL 是否文件提示=TRUE);</FONT>
```
### 参数
```
bool 是否文件提示 - 是否开启文件提示日志
```
### 返回值
```
查看返回值表
```
### 注意事项
```
当HD内部导致中控关闭或者插件失效会一文件形式提示信息
```
### HD环境_开启文件提示 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_开启文件提示 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_添加线程
### 描述
```
添加线程环境
```
### 原型
```
__int64 __stdcall HCEnv_AddThread(__int32 窗口序号,__int32 线程ID,__int32 bDebug=0);
```
### 参数
```
__int32 窗口序号 - 窗口序号（从1开始）
__int32 线程ID - 当前线程ID
__int32 bDebug - 是否是调试模式,如果是那么线程ID可以任意指定
```
### 返回值
```
查看返回值表
```
### 注意事项
```
这个接口用来测试用的,开发者一般用不到
```
### HD环境_添加线程 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_添加线程 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_测试通讯值
### 描述
```
测试是否通讯成功,返回单一值
```
### 原型
```
__int64 __stdcall HCEnv_TestCALL_RetValue(__int32 窗口序号,__int64 rcx=0,__int64 rdx=0,__int64 r8=0,__int64 r9=0,__int64 lparam5=0,__int64 lparam6=0,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号（从1开始）
__int64 rcx - CALL参数
__int64 rdx - CALL参数
__int64 r8 - CALL参数
__int64 r9 - CALL参数
 l5 - CALL参数
 l6 - CALL参数
bool 是否主线程调用 - 是否主线程调用这个CALL,需要挂接主线程
```
### 返回值
```
查看返回值表
```
### 注意事项
```
这个接口用来测试是否环境搭建成功
```
### HD环境_测试通讯值 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_测试通讯值 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCEnv_TestCALL_RetArray
### 描述
```
测试是否通讯成功,返回json字符串
```
### 原型
```
__int64 __stdcall HCEnv_TestCALL_RetArray(__int32 窗口序号,__int64 rcx=0,__int64 rdx=0,__int64 r8=0,__int64 r9=0,__int64 lparam5=0,__int64 lparam6=0,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号（从1开始）
__int64 rcx - CALL参数
__int64 rdx - CALL参数
__int64 r8 - CALL参数
__int64 r9 - CALL参数
 l5 - CALL参数
 l6 - CALL参数
bool 是否主线程调用 - 是否主线程调用这个CALL,需要挂接主线程
```
### 返回值
```
查看返回值表
```
### 注意事项
```
这个接口用来测试是否环境搭建成功
```
### HCEnv_TestCALL_RetArray - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCEnv_TestCALL_RetArray - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCEnv_TestCALL_RetValueEx
### 描述
```
测试是否通讯成功,返回单一值
```
### 原型
```
__int64 __stdcall HCEnv_TestCALL_RetValueEx(__int32 窗口序号,__int32 线程ID,__int64 rcx=0,__int64 rdx=0,__int64 r8=0,__int64 r9=0,__int64 lparam5=0,__int64 lparam6=0,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号（从1开始）
__int32 线程ID - 当前线程ID或者添加的指定ID
__int64 rcx - CALL参数
__int64 rdx - CALL参数
__int64 r8 - CALL参数
__int64 r9 - CALL参数
 l5 - CALL参数
 l6 - CALL参数
bool 是否主线程调用 - 是否主线程调用这个CALL,需要挂接主线程
```
### 返回值
```
查看返回值表
```
### 注意事项
```
这个接口用来测试是否环境搭建成功
```
### HCEnv_TestCALL_RetValueEx - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCEnv_TestCALL_RetValueEx - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_测试通讯字符串Ex
### 描述
```
测试是否通讯成功,返回json字符串
```
### 原型
```
__int64 __stdcall HCEnv_TestCALL_RetArrayEx(__int32 窗口序号,__int32 线程ID,__int64 rcx=0,__int64 rdx=0,__int64 r8=0,__int64 r9=0,__int64 lparam5=0,__int64 lparam6=0,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号（从1开始）
__int32 线程ID - 当前线程ID或者添加的指定ID
__int64 rcx - CALL参数
__int64 rdx - CALL参数
__int64 r8 - CALL参数
__int64 r9 - CALL参数
 l5 - CALL参数
 l6 - CALL参数
bool 是否主线程调用 - 是否主线程调用这个CALL,需要挂接主线程
```
### 返回值
```
查看返回值表
```
### 注意事项
```
这个接口用来测试是否环境搭建成功
```
### HD环境_测试通讯字符串Ex - 基础示例
```
.版本 2

.子程序 _获取扩展窗口句柄
    .局部变量 窗口句柄, 长整数型
    
    窗口句柄 = HD环境_获取绑定窗口句柄Ex (0)
    调试输出 ("扩展窗口句柄: " + 到文本 (窗口句柄))
```
### HD环境_测试通讯字符串Ex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_测试通讯字符串Ex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_设置目标进程位数
### 描述
```
设置目标进程位数
```
### 原型
```
__int64 __stdcall HCEnv_SetProcessType(__int32 进程位数);
```
### 参数
```
__int32 进程位数 - 32/64
```
### 返回值
```
查看返回值表
```
### 注意事项
```
该接口是全局设置,也就是设置了一次,接下来的所有进程都是该位数,可以多次调用切换进程位数,建议使用HCEnv_SetProcessTypeEx这个扩展版本
如果使用了HDEX_InstallPlugin1HDEX_InstallPlugin2HDEX_InstallPlugin3这些接口可以不用调用这个接口设置目标进程位数
如果是自定义通讯流程就需要自己设置后然后初始化序号进行通讯绑定
```
### HD环境_设置目标进程位数 - 基础示例
```
.版本 2

.子程序 _设置进程位数
    .局部变量 设置结果, 逻辑型
    .局部变量 进程位数, 整数型
    .局部变量 系统位数, 整数型
    
    ' 自动检测系统位数
    .如果 (HD系统_当前进程是否X64 ())
        系统位数 = 64
        调试输出 ("检测到64位系统")
    .否则
        系统位数 = 32
        调试输出 ("检测到32位系统")
    .如果结束
    
    ' 设置目标进程位数（通常与系统位数相同）
    进程位数 = 系统位数
    
    ' 参数验证
    .如果 (进程位数 ≠ 32 且 进程位数 ≠ 64)
        调试输出 ("错误：进程位数只能是32或64")
        返回 (假)
    .如果结束
    
    调试输出 ("设置目标进程位数为: " + 到文本 (进程位数) + "位")
    设置结果 = HD环境_设置目标进程位数 (进程位数)
    
    .如果 (设置结果 = 真)
        调试输出 ("进程位数设置成功")
    .否则
        调试输出 ("进程位数设置失败")
    .如果结束
    
    返回 (设置结果)
```
### HD环境_设置目标进程位数 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_设置目标进程位数 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_设置目标进程位数Ex
### 描述
```
指定某个序号绑定的进程位数
```
### 原型
```
__int64 __stdcall HCEnv_SetProcessTypeEx(__int32 窗口序号,__int32 进程位数);
```
### 参数
```
__int32 窗口序号 - 窗口序号
__int32 进程位数 - 32/64
```
### 返回值
```
查看返回值表
```
### 注意事项
```
如果使用了HDEX_InstallPlugin1HDEX_InstallPlugin2HDEX_InstallPlugin3这些接口可以不用调用这个接口设置目标进程位数
如果是自定义通讯流程就需要自己设置后然后初始化序号进行通讯绑定
```
### HD环境_设置目标进程位数Ex - 基础示例
```
.版本 2

.子程序 _设置进程位数Ex
    .局部变量 设置结果, 逻辑型
    .局部变量 窗口序号, 整数型
    .局部变量 进程位数, 整数型
    
    窗口序号 = 0
    进程位数 = 64  ' 设置为64位进程
    设置结果 = HD环境_设置目标进程位数Ex (窗口序号, 进程位数)
    
    .如果 (设置结果 = 真)
        调试输出 ("窗口" + 到文本 (窗口序号) + "进程位数设置成功: " + 到文本 (进程位数) + "位")
    .否则
        调试输出 ("进程位数设置失败")
    .如果结束
```
### HD环境_设置目标进程位数Ex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_设置目标进程位数Ex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_设置中控事件处理回调函数
### 描述
```
设置中控事件处理回调函数
```
### 原型
```
__int64 __stdcall HCEnv_SetHandleEventCallBack(__int64 funCallBack);
```
### 参数
```
__int64 funCallBack - 事件处理函数地址
```
### 返回值
```
查看返回值表
```
### 注意事项
```
这个回调函数作用于当自定义模块通知中控的时候
中控事件处理回调函数接口类型:
typedef__int32 (__stdcall* HandleEventFunType)(__int32 窗口序号,__int32 插件序号,HDHandleEventInfoInfo);
HDHandleEventInfo结构体:
typedefstructHDHandleEventInfo\n处理事件{__int32 m_callType;\n自定义HDValuem_call;HDValuem_rcx;HDValuem_rdx;HDValuem_r8;HDValuem_r9;HDValuem_lparam5;HDValuem_lparam6;HDValuem_lparam7;HDValuem_lparam8;HDValuem_value;HDValuem_size;charm_buffer[MAX_PATH];charm_buffer2[MAX_PATH];HDValue* m_pRetValue;\n值单独char* m_pRetJson;\n字符串返回}HDHandleEventInfo;
代码案例:
__int32 HCLogin::HandleEvent(__int32 窗口序号,__int32 插件序号,HDHandleEventInfoInfo){HDbgPrint f_Normal(\"处理接受事件->窗口序号:%dcallType:%dbuffer1:%sbuffer2:%scall:%llXrcx:%llXrdx:%llX\",窗口序号,Info.m_callType,Info.m_buffer,Info.m_buffer2,Info.m_call,Info.m_rcx,Info.m_rdx);if(Info.m_callType==1){* Info.m_pRetValue=999;autoret=HCMKB_UnBind(窗口序号);HDbgPrint f_Normal(\"解绑后台ret:%d\",ret);return8;}elseif(Info.m_callType==2){\n处理逻辑* Info.m_pRetValue=123;sprint f_s(Info.m_pRetJson,1024* 10,\"%s\",\"我是中控\");\n672637autoret=HCMKB_Bind(窗口序号,Info.m_call,\"1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|0|1|\");HDbgPrint f_Normal(\"绑定后台ret:%d\",ret);if(ret==1){Sleep(1000);ret=HCMKB_MoveTo(窗口序号,672,610,0);HDbgPrint f_Normal(\"模拟移动一次->672610ret:%d\",ret);ret=HCMKB_LeftClick(窗口序号);HDbgPrint f_Normal(\"模拟点击一次->ret:%d\",ret);}return1024* 10;\n大于8认为是字符串}* Info.m_pRetValue=1;return8;}
```
### HD环境_设置中控事件处理回调函数 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_设置中控事件处理回调函数 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCEnv_SetShutDownCallBack
### 描述
```
设置关闭回调函数(处理HD功能失效,内部自动关闭中控前的操作)
```
### 原型
```
__int64 __stdcall HCEnv_SetShutDownCallBack(__int64 funCallBack);
```
### 参数
```
__int64 funCallBack - 事件处理函数地址
```
### 返回值
```
查看返回值表
```
### 注意事项
```
当HD出现异常或者失效或者网络验证出现断线,会在自动关闭自身在期间会先调用这个回调(这个回调自己做好关闭前处理工作)然后会自动调用微软API接口ExitProcess();结束自身
在这个回调用户可以自行处理自己的业务逻辑
1.资源清理逻辑
2.接口释放逻辑
3.自启逻辑
4.自定义处理逻辑
回调函数接口类型:
typedef__int32 (__stdcall* ShutDownEventFunType)(__int32 code);
code:错误代码
```
### HCEnv_SetShutDownCallBack - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCEnv_SetShutDownCallBack - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCEnv_SetPidCheckBack
### 描述
```
设置PID检查回调(内部检查PID不存在会触发这个回调)
```
### 原型
```
__int64 __stdcall HCEnv_SetPidCheckBack(__int64 checkFun);
```
### 参数
```
__int64 checkFun - 检查回调和安装插件那个检查回调一样的函数类型触发条件
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.这是设置全局PID检查回调
2.内部检查PID不存在会触发这个回调
3.如果没有调用此接口设置全局PID检查回调,那么对于4种安装插件方式中,当内部检查不到PID存在也会触发检查回调并传递给回调参数窗口序号:0之前窗口序号:0检查PID:pid提示值:8
回调函数接口类型:
typedef__int64 (__stdcall* CHECKINSTALLPLUGint YPE)(int windowsIndex,int preWindowsIndex,int checkPid,int error);
windowsIndex:窗口序号
preWindowsIndex:窗口序号
checkPid:当前检查的PID
error:传递8表示需要检查PID
```
### HCEnv_SetPidCheckBack - 基础示例
```
.版本 2

.子程序 _设置通讯检测间隔
    .局部变量 设置结果, 逻辑型
    .局部变量 间隔时间, 整数型
    
    间隔时间 = 50  ' 设置为50毫秒
    设置结果 = HD环境_设置通讯检测间隔 (间隔时间)
    
    .如果 (设置结果 = 真)
        调试输出 ("通讯检测间隔设置成功: " + 到文本 (间隔时间) + "毫秒")
    .否则
        调试输出 ("通讯检测间隔设置失败")
    .如果结束
```
### HCEnv_SetPidCheckBack - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCEnv_SetPidCheckBack - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_设置通讯检测间隔
### 描述
```
设置通讯检测间隔毫秒
```
### 原型
```
__int64 __stdcall HCEnv_SetCheckComItlTime(__int32 通讯检测间隔毫秒=20);
```
### 参数
```
__int32 通讯检测间隔毫秒 - 默认就行,越小响应越快,CPU占用了越高(也可以调用HCEnv_InitEx设置)
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.值越小响应越快,随之带来的效率更高但是会导致CPU利用率变高2.值的大小根据当前的项目指定,对于一直要实时响应的最好小点
```
### HD环境_设置通讯检测间隔 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_设置通讯检测间隔 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_设置回调响应间隔
### 描述
```
设置回调响应毫秒
```
### 原型
```
__int64 __stdcall HCEnv_SetCheckCallBackTime(__int32 回调响应毫秒=5);
```
### 参数
```
__int32 回调响应毫秒 - 默认就行,越小响应越快,CPU占用了越高(也可以调用HCEnv_InitEx设置)
```
### 返回值
```
查看返回值表
```
### 注意事项
```
1.值越小响应越快,随之带来的效率更高但是会导致CPU利用率变高2.值的大小根据当前的项目指定,对于一直要实时响应的最好小点
```
### HD环境_设置回调响应间隔 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_设置回调响应间隔 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_强制结束线程
### 描述
```
强制结束当前线程(可以在卸载环境后调用)
```
### 原型
```
__int64 __stdcall HCEnv_TerminateThread(__int32 窗口序号,__int32 threadId,BOOL 是否操作锁=TRUE);
```
### 参数
```
__int32 窗口序号 - 指定当前强制关闭线程所操作的窗口序号
__int32 threadId - 强制关闭的线程ID,调用此接口的线程不要和结束的线程是同一个(虽然内部有检查)
bool 是否操作锁 - 一般为了安全的强制关闭线程,必须为真,否则会很有可能出现死锁的情况
```
### 返回值
```
查看返回值表
```
### 注意事项
```
强制结束当前线程内部会对锁操作循环拿到锁才会强制关闭并返回成功此接口小心使用1.不到万不得已不要强制关闭线程(因为强制关闭线程不管在任何时候都有可能造成不可能预计的BUG)2.调用此接口的线程不要和结束的线程是同一个(虽然内部有检查)3.该接口如果参数:是否操作锁为真,那么会堵塞,直到拿到锁权限后,才会强制关闭线程,然后解锁(防止死锁).
```
### HD环境_强制结束线程 - 基础示例
```
.版本 2

.子程序 HDUI回调, 长整数型, 公开
    .参数 窗口索引, 整数型
    .参数 日志信息, 文本型
    .参数 结束1, 逻辑型
    .参数 暂停1, 逻辑型
    .参数 状态1, 整数型
    .参数 结束2, 逻辑型
    .参数 暂停2, 逻辑型
    .参数 状态2, 整数型
    .局部变量 列表索引, 整数型
    .局部变量 角色信息, 文本型
    .局部变量 状态信息, 文本型

    调试输出 ("HDUI回调:", 窗口索引, 日志信息)
    
    ' 窗口索引转列表索引（1~62 → 0~61）
    列表索引 = 窗口索引 - 1
    
    .如果 (列表索引 >= 0 且 列表索引 < #HD常量_最大多开数)
        ' 更新超级列表框显示信息
        _启动窗口.超级列表框1.置标题 (列表索引, #列_序号, 到文本 (账号信息数组 [窗口索引].序号))
        _启动窗口.超级列表框1.置标题 (列表索引, #列_账号, 账号信息数组 [窗口索引].账号)
        _启动窗口.超级列表框1.置标题 (列表索引, #列_密码, 账号信息数组 [窗口索引].密码)
        
        ' 角色信息格式：角色名|角色索引|等级|金币|元宝
        角色信息 = 账号信息数组 [窗口索引].角色名 + "|" + 到文本 (账号信息数组 [窗口索引].角色索引) + 
                  "|" + 到文本 (账号信息数组 [窗口索引].人物等级) + "|" + 到文本 (账号信息数组 [窗口索引].金币) + 
                  "|" + 到文本 (账号信息数组 [窗口索引].元宝)
        _启动窗口.超级列表框1.置标题 (列表索引, #列_角色信息, 角色信息)
        
        ' 当前操作日志
        _启动窗口.超级列表框1.置标题 (列表索引, #列_当前操作, 日志信息)
        
        ' 线程状态信息：[主]状态|[次]状态
        状态信息 = "[主]：E:" + 到文本 (结束1) + " P：" + 到文本 (暂停1) + " S：" + HD多线程_获取线程状态说明 (状态1) + 
                  "|[次]：E:" + 到文本 (结束2) + " P：" + 到文本 (暂停2) + " S：" + HD多线程_获取线程状态说明 (状态2)
        _启动窗口.超级列表框1.置标题 (列表索引, #列_状态信息, 状态信息)
        
        ' 其他信息
        _启动窗口.超级列表框1.置标题 (列表索引, #列_备注, 账号信息数组 [窗口索引].备注)
        _启动窗口.超级列表框1.置标题 (列表索引, #列_IP端口, 账号信息数组 [窗口索引].IP端口)
    .如果结束
    
    返回 (1)
```
### HD环境_强制结束线程 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_强制结束线程 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_强制结束线程Ex
### 描述
```
强制结束当前线程(可以在卸载环境后调用)
```
### 原型
```
__int64 __stdcall HCEnv_TerminateThreadEx(__int32 窗口序号,__int64 threadHandle,BOOL 是否操作锁=TRUE);
```
### 参数
```
__int32 窗口序号 - 指定当前强制关闭线程所操作的窗口序号
__int64 threadHandle - 强制关闭的线程句柄,调用此接口的线程不要和结束的线程是同一个(虽然有检查但是可能会崩溃)
bool 是否操作锁 - 一般为了安全的强制关闭线程,必须为真,否则会很有可能出现死锁的情况
```
### 返回值
```
查看返回值表
```
### 注意事项
```
强制结束当前线程内部会对锁操作循环拿到锁才会强制关闭并返回成功此接口小心使用1.不到万不得已不要强制关闭线程(因为强制关闭线程不管在任何时候都有可能造成不可能预计的BUG)2.调用此接口的线程不要和结束的线程是同一个(虽然内部有检查)3.该接口如果参数:是否操作锁为真,那么会堵塞,直到拿到锁权限后,才会强制关闭线程,然后解锁(防止死锁).
```
### HD环境_强制结束线程Ex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_强制结束线程Ex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD环境_关闭绑定进程
### 描述
```
关闭绑定的目标窗口
```
### 原型
```
__int64 __stdcall HCEnv_ExitProcess(__int32 窗口序号);
```
### 参数
```
__int32 窗口序号 - 指定当前强制关闭线程所操作的窗口序号
```
### 返回值
```
查看返回值表
```
### 注意事项
```
内部实现可能是正常关闭也可能是强制关闭 至于是哪一种会根据实际情况动态调用
```
### HD环境_关闭绑定进程 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD环境_关闭绑定进程 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
