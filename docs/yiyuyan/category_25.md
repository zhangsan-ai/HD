# 🛰️ 内存操作模块(M)
## 📌 函数: HD内存_特征码
### 描述
```
特征码查找
```
### 原型
```
__int64 __stdcall HCM_FindCode(__int32 窗口序号,char* 特征码字符串地址,__int32 偏移,__int32 次数,__int32 type=1,char* 模块名字=NULL);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
char* 特征码字符串地址 - 特征码字符串地址(支持??)
__int32 偏移 - 正负偏移
__int32 次数 - 找到的第几次从1开始
__int32 type - 获取的是(基地址/CALL地址/直接地址/地址中的值)1为地址2为基地址3为CALL4为地址中的值
char* 模块名字 - 在指定的模块中搜索,默认为主模块NULL为默认
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD内存_特征码 - 基础示例
```
.版本 2

.子程序 _扩展图片查找
    .局部变量 查找结果, 文本型
    
    查找结果 = HD识图_查找图片Ex (0, 0, 0, 1920, 1080, "target.bmp", 0.9)
    调试输出 ("扩展图片查找结果: " + 查找结果)
```
### HD内存_特征码 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD内存_特征码 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD内存_特征码Ex
### 描述
```
特征码查找(通过指定地址)
```
### 原型
```
__int64 __stdcall HCM_FindCodeEx(__int32 窗口序号,__int64 开始地址,__int64 扫描范围大小,char* 特征码字符串地址,__int32 偏移,__int32 次数,__int32 type=1);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int64 开始地址 - 指定开始扫描的地址
__int64 扫描范围大小 - 指定开始扫描的地址大小,结束地址等于开始地址+扫描范围大小
char* 特征码字符串地址 - 特征码字符串地址(支持??)
__int32 偏移 - 正负偏移
__int32 次数 - 找到的第几次从1开始
__int32 type - 获取的是(基地址/CALL地址/直接地址/地址中的值)1为地址2为基地址3为CALL4为地址中的值
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD内存_特征码Ex - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD内存_特征码Ex - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD内存_读表达式
### 描述
```
读整数数据
```
### 原型
```
__int64 __stdcall HCM_Read(__int32 窗口序号,char* 表达式字符串地址,__int32 读取大小,char* 模块名字=NULL,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
char* 表达式字符串地址 - 表达式字符串地址(格式)
__int32 读取大小 - 读取大小支持1248大小
char* 模块名字 - 在指定的模块中读写,默认为主模块
bool 是否主线程调用 - 是否主线程调用
 格式 - 
 相对偏移]+x]+y]+z取地址相对偏移]+x]+y]+z]取地址值\n如 - 0x123456]+0x56]-0x44]第一个偏移表示的是基地址的偏移不是基地址地址\n加号\"+\"可要可不要\n减号\"-\"负偏移需要\n最后一个\"]\"加了取地址里面值不加是地址
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD内存_读表达式 - 基础示例
```
.版本 2

.子程序 _读取字节流示例
    .局部变量 字节数据, 字节集
    .局部变量 窗口序号, 整数型
    .局部变量 数据地址, 长整数型
    .局部变量 数据长度, 整数型
    .局部变量 i, 整数型
    .局部变量 十六进制串, 文本型
    
    窗口序号 = 0
    数据地址 = 4194304  ' 0x400000
    数据长度 = 16
    
    字节数据 = HD内存_读地址字节流 (窗口序号, 数据地址, 数据长度)
    
    .如果 (取字节集长度 (字节数据) > 0)
        十六进制串 = ""
        .计次循环首 (取字节集长度 (字节数据), i)
            十六进制串 = 十六进制串 + " " + 到十六进制 (字节数据 [i], 2)
        .计次循环尾 ()
        
        调试输出 ("读取字节数据: " + 十六进制串)
    .否则
        调试输出 ("读取字节数据失败")
    .如果结束
```
### HD内存_读表达式 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD内存_读表达式 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD内存_读地址
### 描述
```
读整数数据
```
### 原型
```
__int64 __stdcall HCM_ReadAddr(__int32 窗口序号,__int64 addr,__int32 读取大小,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int64 addr - 需要读的内存地址
__int32 读取大小 - 读取大小支持1248大小
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD内存_读地址 - 基础示例
```
.版本 2

.子程序 _读取内存地址示例
    .局部变量 读取值, 长整数型
    .局部变量 窗口序号, 整数型
    .局部变量 内存地址, 长整数型
    .局部变量 数据类型, 整数型
    .局部变量 数据类型名称, 文本型
    
    窗口序号 = 0
    内存地址 = 8388608  ' 0x800000，示例地址
    数据类型 = 4  ' 4字节整数
    
    ' 数据类型说明
    .判断开始 (数据类型)
        .如果 (1)
            数据类型名称 = "字节型(1字节)"
        .如果 (2)
            数据类型名称 = "短整数型(2字节)"
        .如果 (4)
            数据类型名称 = "整数型(4字节)"
        .如果 (8)
            数据类型名称 = "长整数型(8字节)"
        .默认
            数据类型名称 = "未知类型"
    .判断结束
    
    调试输出 ("准备读取内存...")
    调试输出 ("目标地址: 0x" + 到十六进制 (内存地址))
    调试输出 ("数据类型: " + 数据类型名称)
    
    ' 检查地址是否可读
    .如果 (HD内存_地址是否可读 (窗口序号, 内存地址))
        读取值 = HD内存_读地址 (窗口序号, 内存地址, 数据类型)
        
        调试输出 ("✓ 读取成功！")
        调试输出 ("十进制值: " + 到文本 (读取值))
        调试输出 ("十六进制值: 0x" + 到十六进制 (读取值))
        
        ' 根据数值范围进行分析
        .如果 (读取值 = 0)
            调试输出 ("注意：读取到空值，可能是未初始化的内存")
        .否则_如果 (读取值 > 0 且 读取值 < 65536)
            调试输出 ("分析：可能是计数器或标识符")
        .否则_如果 (读取值 ≥ 4194304)  ' 0x400000
            调试输出 ("分析：可能是内存地址指针")
        .否则
            调试输出 ("分析：普通数值")
        .如果结束
        
    .否则
        调试输出 ("× 地址不可读或无效")
        调试输出 ("建议：检查目标进程是否正确绑定")
    .如果结束
    
    返回 (读取值)
```
### HD内存_读地址 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD内存_读地址 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD内存_写表达式
### 描述
```
写整数数据
```
### 原型
```
__int64 __stdcall HCM_Write(__int32 窗口序号,char* 表达式字符串地址,__int64 value,__int32 写入大小,char* 模块名字=NULL,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
char* 表达式字符串地址 - 表达式字符串地址最后一个必须+“]”才有意义否则会忽视最后一个偏移
__int64 value - 写入值
__int32 写入大小 - 写入值的字节大小(最大就8字节)
char* 模块名字 - 在指定的模块中读写,默认为主模块
bool 是否主线程调用 - 是否主线程调用
 格式 - 
 \n【偏移表达式格式】\n尽支持十六进制格式 - XXX]XXX]XXX]XXX]\n如
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD内存_写表达式 - 基础示例
```
.版本 2

.子程序 _写单精度浮点示例
    .局部变量 写入结果, 逻辑型
    .局部变量 浮点值, 小数型
    
    浮点值 = 99.5
    写入结果 = HD内存_写表达式单浮点 (0, "game.exe+0x123456+0x20", 浮点值)
    
    .如果 (写入结果)
        调试输出 ("单精度浮点数写入成功: " + 到文本 (浮点值))
    .否则
        调试输出 ("单精度浮点数写入失败")
    .如果结束
```
### HD内存_写表达式 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD内存_写表达式 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD内存_写地址
### 描述
```
写整数数据
```
### 原型
```
__int64 __stdcall HCM_WriteAddr(__int32 窗口序号,__int64 addr,__int64 value,__int32 写入大小,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int64 addr - 需要写的内存地址
__int64 value - 写入的值
__int32 写入大小 - 写入大小(最大8字节)
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HD内存_写地址 - 基础示例
```
.版本 2

.子程序 _写入内存地址示例
    .局部变量 写入结果, 逻辑型
    .局部变量 窗口序号, 整数型
    .局部变量 内存地址, 长整数型
    .局部变量 写入值, 长整数型
    
    窗口序号 = 0
    内存地址 = 8388608  ' 0x800000
    写入值 = 9999
    
    写入结果 = HD内存_写地址 (窗口序号, 内存地址, 4, 写入值)
    
    .如果 (写入结果 = 真)
        调试输出 ("内存写入成功，地址: 0x" + 到十六进制 (内存地址) + "，值: " + 到文本 (写入值))
        
        ' 验证写入结果
        .局部变量 验证值, 长整数型
        验证值 = HD内存_读地址 (窗口序号, 内存地址, 4)
        .如果 (验证值 = 写入值)
            调试输出 ("写入验证成功")
        .否则
            调试输出 ("写入验证失败")
        .如果结束
    .否则
        调试输出 ("内存写入失败")
    .如果结束
```
### HD内存_写地址 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD内存_写地址 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD内存_读表达式字节流
### 描述
```
读字节流数据
```
### 原型
```
__int64 __stdcall HCM_ReadData(__int32 窗口序号,char* 表达式字符串地址,BYTE* byteBuffer,__int32 byBufferSize,__int32 读取大小,char* 模块名字=NULL,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
char* 表达式字符串地址 - 表达式字符串地址(格式)读字节流最后一个必须+“]”才有意义否则会忽视最后一个偏移
byte* byteBuffer - 存放读取字节集缓冲区
__int32 byBufferSize - 存放读取字节集缓冲区的大小
__int32 读取大小 - 读取大小1到100KB大小
char* 模块名字 - 在指定的模块中读写,默认为主模块
bool 是否主线程调用 - 是否主线程调用
 格式 - 
 \n【偏移表达式格式】\n尽支持十六进制格式 - XXX]XXX]XXX]XXX]\n如
```
### 返回值
```
查看返回值表
高4字节是GetLastError()返回
低4字节是HD返回值
```
### 注意事项
```
json返回字节流利用HCEnv_GetRetJson拿到返回地址,提取的字节数为读取大小数最大读取100KB字节大小,注意这个限制,否则会报错
```
### HD内存_读表达式字节流 - 基础示例
```
.版本 2

.子程序 _读表达式ANSI文本示例
    .局部变量 文本内容, 文本型
    
    文本内容 = HD内存_读表达式文本Annsi (0, "game.exe+0x123456+0x30", 50)
    调试输出 ("读取到的ANSI文本: " + 文本内容)
```
### HD内存_读表达式字节流 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD内存_读表达式字节流 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCM_ReadFD
### 描述
```
读单/双浮点数
```
### 原型
```
__int64 __stdcall HCM_ReadFD(__int32 窗口序号,char* 表达式字符串地址,__int32 读取大小,char* 模块名字=NULL,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
char* 表达式字符串地址 - 表达式字符串地址(格式)最后一个必须+“]”才有意义否则会忽视最后一个偏移
__int32 读取大小 - 4float单浮点8double双浮点
char* 模块名字 - 在指定的模块中读写,默认为主模块
bool 是否主线程调用 - 是否主线程调用
 格式 - 
 \n【偏移表达式格式】\n尽支持十六进制格式 - XXX]XXX]XXX]XXX]\n如
```
### 返回值
```
查看返回值表
```
### 注意事项
```
返回结果以float举例:json返回字符串如:{\\"error\\":0,\\"ret\\":[{\\"bRet\\":1,\\"iError\\":0,\\"value\\":999.000}]}
```
### HCM_ReadFD - 基础示例
```
.版本 2

.子程序 _读表达式Unicode文本示例
    .局部变量 文本内容, 文本型
    
    文本内容 = HD内存_读表达式文本Unicode (0, "game.exe+0x123456+0x40", 50)
    调试输出 ("读取到的Unicode文本: " + 文本内容)
```
### HCM_ReadFD - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCM_ReadFD - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD内存_读地址字节流
### 描述
```
读字节流数据
```
### 原型
```
__int64 __stdcall HCM_ReadDataAddr(__int32 窗口序号,__int64 addr,BYTE* byteBuffer,__int32 byBufferSize,__int32 读取大小,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int64 addr - 目标进程的地址
byte* byteBuffer - 存放读取字节集缓冲区
__int32 byBufferSize - 存放读取字节集缓冲区的大小
__int32 读取大小 - 1到100KB大小
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
高4字节是GetLastError()返回
低4字节是HD返回值
```
### 注意事项
```
json返回字节流利用HCEnv_GetRetJson拿到返回地址,提取的字节数为读取大小数最大读取100KB字节大小,注意这个限制,否则会报错
```
### HD内存_读地址字节流 - 基础示例
```
.版本 2

.子程序 _读取Unicode文本示例
    .局部变量 读取文本, 文本型
    .局部变量 窗口序号, 整数型
    .局部变量 文本地址, 长整数型
    
    窗口序号 = 0
    文本地址 = 16777216  ' 0x1000000
    
    读取文本 = HD内存_读地址文本Unicode (窗口序号, 文本地址, 30)
    
    .如果 (读取文本 ≠ "")
        调试输出 ("读取到Unicode文本: " + 读取文本)
        
        ' Unicode文本通常用于中文等多字节字符
        .如果 (取文本长度 (读取文本) > 0)
            调试输出 ("文本长度: " + 到文本 (取文本长度 (读取文本)) + "个字符")
        .如果结束
    .否则
        调试输出 ("未读取到Unicode文本")
    .如果结束
```
### HD内存_读地址字节流 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD内存_读地址字节流 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCM_ReadFDAddr
### 描述
```
读单/双浮点数
```
### 原型
```
__int64 __stdcall HCM_ReadFDAddr(__int32 窗口序号,__int64 addr,__int32 读取大小,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int64 addr - 目标进程的地址
__int32 读取大小 - 4float单浮点8double双浮点
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
```
### 注意事项
```
读取大小:4float单浮点8double双浮点以float举例:json返回字符串如:\"999.0000\"
```
### HCM_ReadFDAddr - 基础示例
```
.版本 2

.子程序 _读地址UTF8文本示例
    .局部变量 文本内容, 文本型
    .局部变量 文本地址, 长整数型
    
    文本地址 = 8388608  ' 0x800000
    文本内容 = HD内存_读地址文本UTF8 (0, 文本地址, 100)
    调试输出 ("UTF8文本内容: " + 文本内容)
```
### HCM_ReadFDAddr - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCM_ReadFDAddr - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD内存_写表达式字节流
### 描述
```
写字节流数据
```
### 原型
```
__int64 __stdcall HCM_WriteData(__int32 窗口序号,char* 表达式字符串地址,char* byteBuffer,__int32 写入大小,char* 模块名字=NULL,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
char* 表达式字符串地址 - 表达式字符串地址(格式)
char* byteBuffer - 字节流缓冲区地址
__int32 写入大小 - 写入大小1到100KB大小
char* 模块名字 - 在指定的模块中读写,默认为主模块
bool 是否主线程调用 - 是否主线程调用
 格式 - 
 \n【偏移表达式格式】\n尽支持十六进制格式 - XXX]XXX]XXX]XXX]\n如
```
### 返回值
```
查看返回值表
高4字节是GetLastError()返回
低4字节是HD返回值
```
### 注意事项
```
最大写入100KB字节大小,注意这个限制,否则会报错json返回值{\\"error\\":0,\\"ret\\":[{\\"bRet\\":1,\\"iError\\":0}]}
```
### HD内存_写表达式字节流 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD内存_写表达式字节流 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCM_WriteF
### 描述
```
写单浮点数4字节
```
### 原型
```
__int64 __stdcall HCM_WriteF(__int32 窗口序号,char* 表达式字符串地址,floatvalue,char* 模块名字=NULL,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
char* 表达式字符串地址 - 表达式字符串地址(格式)最后一个必须+“]”才有意义否则会忽视最后一个偏移
 value - 需要写入的单浮点数
char* 模块名字 - 在指定的模块中读写,默认为主模块
bool 是否主线程调用 - 是否主线程调用
 格式 - 
 \n【偏移表达式格式】\n尽支持十六进制格式 - XXX]XXX]XXX]XXX]\n如
```
### 返回值
```
查看返回值表
```
### 注意事项
```
json返回值{\\"error\\":0,\\"ret\\":[{\\"bRet\\":1,\\"iError\\":0}]}
```
### HCM_WriteF - 基础示例
```
.版本 2

.子程序 _写表达式字节流示例
    .局部变量 写入结果, 逻辑型
    .局部变量 字节数据, 字节集
    
    字节数据 = { 144, 144, 144, 195 }  ' NOP NOP NOP RET
    写入结果 = HD内存_写表达式节流 (0, "game.exe+0x123456+0x70", 字节数据, 4)
    
    .如果 (写入结果)
        调试输出 ("字节数据写入成功")
    .否则
        调试输出 ("字节数据写入失败")
    .如果结束
```
### HCM_WriteF - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCM_WriteF - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCM_WriteD
### 描述
```
写双浮点数8字节
```
### 原型
```
__int64 __stdcall HCM_WriteD(__int32 窗口序号,char* 表达式字符串地址,doublevalue,char* 模块名字=NULL,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
char* 表达式字符串地址 - 表达式字符串地址(格式)最后一个必须+“]”才有意义否则会忽视最后一个偏移
 value - 需要写入的双浮点数
char* 模块名字 - 在指定的模块中读写,默认为主模块
bool 是否主线程调用 - 是否主线程调用
 格式 - 
 \n【偏移表达式格式】\n尽支持十六进制格式 - XXX]XXX]XXX]XXX]\n如
```
### 返回值
```
查看返回值表
```
### 注意事项
```
json返回值{\\"error\\":0,\\"ret\\":[{\\"bRet\\":1,\\"iError\\":0}]}
```
### HCM_WriteD - 基础示例
```
.版本 2

.子程序 测试写入机器码, 长整数型, 公开
    .局部变量 目标PID, 整数型
    .局部变量 机器码, 字节集
    .局部变量 写入地址, 长整数型
    .局部变量 汇编代码, 文本型
    .局部变量 错误1, 长整数型
    .局部变量 错误2, 长整数型
    
    目标PID ＝ 1234  ' 目标进程ID
    汇编代码 ＝ "nop" ＋ #换行符 ＋ "nop" ＋ #换行符 ＋ "ret"
    
    ' 先转换汇编为机器码
    机器码 ＝ HD汇编_转机器码 (8, 汇编代码, 错误1, 错误2, 100)
    .如果 (取字节集长度 (机器码) ＞ 0)
        调试输出 ("机器码准备就绪，长度：", 取字节集长度 (机器码))
        
        ' 写入机器码到目标进程
        写入地址 ＝ HD汇编_写入机器码 (目标PID, 机器码)
        .如果 (写入地址 ≠ 0)
            调试输出 ("机器码写入成功")
            调试输出 ("写入地址：", 到十六进制 (写入地址))
            调试输出 ("可以使用HD驱动创建远线程来执行此地址的代码")
        .否则
            调试输出 ("机器码写入失败，请检查HD驱动是否正常安装")
        .如果结束
    .否则
        调试输出 ("机器码生成失败，无法写入")
    .如果结束
    
    返回 (写入地址)
```
### HCM_WriteD - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCM_WriteD - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HD内存_写地址字节流
### 描述
```
写字节流数据
```
### 原型
```
__int64 __stdcall HCM_WriteDataAddr(__int32 窗口序号,__int64 addr,char* byteBuffer,__int32 写入大小,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int64 addr - 目标进程的地址
char* byteBuffer - 字节缓冲区,最大写入100KB
__int32 写入大小 - 1到100KB大小
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
高4字节是GetLastError()返回
低4字节是HD返回值
```
### 注意事项
```
json返回字节流利用HCEnv_GetRetJson拿到返回地址,提取的字节数为读取大小数最大读取100KB字节大小,注意这个限制,否则会报错
```
### HD内存_写地址字节流 - 基础示例
```
.版本 2

.子程序 _写入双浮点示例
    .局部变量 写入结果, 逻辑型
    .局部变量 窗口序号, 整数型
    .局部变量 写入地址, 长整数型
    .局部变量 双精度值, 双精度小数型
    
    窗口序号 = 0
    写入地址 = 16777216  ' 0x1000000
    双精度值 = 2.718281828459045  ' e值
    
    写入结果 = HD内存_写地址双浮点 (窗口序号, 写入地址, 双精度值)
    
    .如果 (写入结果 = 真)
        调试输出 ("双精度浮点数写入成功: " + 到文本 (双精度值))
        
        ' 验证写入
        .局部变量 验证文本, 文本型
        验证文本 = HD内存_读地址浮点数 (窗口序号, 写入地址, 8)
        .如果 (验证文本 ≠ "")
            调试输出 ("验证读取: " + 验证文本)
        .如果结束
    .否则
        调试输出 ("双精度浮点数写入失败")
    .如果结束
```
### HD内存_写地址字节流 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HD内存_写地址字节流 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCM_WriteAddrF
### 描述
```
写单浮点数4字节
```
### 原型
```
__int64 __stdcall HCM_WriteAddrF(__int32 窗口序号,__int64 addr,floatvalue,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int64 addr - 目标进程地址
 value - float单浮点值
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HCM_WriteAddrF - 基础示例
```
.版本 2

.子程序 _写入单浮点示例
    .局部变量 写入结果, 逻辑型
    .局部变量 窗口序号, 整数型
    .局部变量 写入地址, 长整数型
    .局部变量 浮点值, 小数型
    
    窗口序号 = 0
    写入地址 = 16777216  ' 0x1000000
    浮点值 = 3.14159  ' π值
    
    写入结果 = HD内存_写地址单浮点 (窗口序号, 写入地址, 浮点值)
    
    .如果 (写入结果 = 真)
        调试输出 ("单精度浮点数写入成功: " + 到文本 (浮点值))
        
        ' 验证写入
        .局部变量 验证文本, 文本型
        验证文本 = HD内存_读地址浮点数 (窗口序号, 写入地址, 4)
        .如果 (验证文本 ≠ "")
            调试输出 ("验证读取: " + 验证文本)
        .如果结束
    .否则
        调试输出 ("单精度浮点数写入失败")
    .如果结束
```
### HCM_WriteAddrF - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCM_WriteAddrF - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCM_WriteAddrD
### 描述
```
写双浮点数8字节
```
### 原型
```
__int64 __stdcall HCM_WriteAddrD(__int32 窗口序号,__int64 addr,doublevalue,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int64 addr - 目标进程地址
 value - double单浮点值
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HCM_WriteAddrD - 基础示例
```
.版本 2

.子程序 _写双精度浮点示例
    .局部变量 写入结果, 逻辑型
    .局部变量 双精度值, 双精度小数型
    
    双精度值 = 123.456789
    写入结果 = HD内存_写表达式双浮点 (0, "game.exe+0x123456+0x24", 双精度值)
    
    .如果 (写入结果)
        调试输出 ("双精度浮点数写入成功: " + 到文本 (双精度值))
    .否则
        调试输出 ("双精度浮点数写入失败")
    .如果结束
```
### HCM_WriteAddrD - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCM_WriteAddrD - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCM_GetModuleBase
### 描述
```
获取模块地址
```
### 原型
```
__int64 __stdcall HCM_GetModuleBase(__int32 窗口序号,char* 模块名字=NULL,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
char* 模块名字 - NULL默认获取主模块首地址
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HCM_GetModuleBase - 基础示例
```
.版本 2

.子程序 _获取模块地址示例
    .局部变量 模块地址, 长整数型
    .局部变量 窗口序号, 整数型
    .局部变量 模块名, 文本型
    
    窗口序号 = 0
    
    ' 获取主模块基址
    模块地址 = HD内存_获取模块地址 (窗口序号, "")
    .如果 (模块地址 > 0)
        调试输出 ("主模块基址: 0x" + 到十六进制 (模块地址))
    .如果结束
    
    ' 获取指定DLL模块基址
    模块名 = "kernel32.dll"
    模块地址 = HD内存_获取模块地址 (窗口序号, 模块名)
    .如果 (模块地址 > 0)
        调试输出 (模块名 + "基址: 0x" + 到十六进制 (模块地址))
    .否则
        调试输出 ("未找到模块: " + 模块名)
    .如果结束
```
### HCM_GetModuleBase - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCM_GetModuleBase - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCM_GetModuleFunAddr
### 描述
```
获取模块中的导出接口地址
```
### 原型
```
__int64 __stdcall HCM_GetModuleFunAddr(__int32 窗口序号,char* 模块名字=NULL,char* 函数名字=NULL,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
char* 模块名字 - NULL默认获取主模块首地址
char* 函数名字 - 导出接口名字
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
成功:返回地址
```
### 注意事项
```
无
```
### HCM_GetModuleFunAddr - 基础示例
```
.版本 2

.子程序 _获取API地址示例
    .局部变量 函数地址, 长整数型
    .局部变量 窗口序号, 整数型
    .局部变量 模块名, 文本型
    .局部变量 函数名, 文本型
    
    窗口序号 = 0
    模块名 = "kernel32.dll"
    函数名 = "CreateFileA"
    
    函数地址 = HD内存_获取模块接口地址 (窗口序号, 模块名, 函数名)
    
    .如果 (函数地址 > 0)
        调试输出 (函数名 + "地址: 0x" + 到十六进制 (函数地址))
        
        ' 可以用于Hook或调用
    .否则
        调试输出 ("未找到API函数: " + 函数名)
    .如果结束
```
### HCM_GetModuleFunAddr - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCM_GetModuleFunAddr - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCM_IsBadReadAddr
### 描述
```
判断指定地址是否在目标进程中有效可读
```
### 原型
```
__int64 __stdcall HCM_IsBadReadAddr(__int32 窗口序号,__int64 addr,__int32 size,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int64 addr - 目标进程地址
__int32 size - 地址大小一般32位是4字节64位是8字节
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
```
### 注意事项
```
无
```
### HCM_IsBadReadAddr - 基础示例
```
.版本 2

.子程序 _检查地址可读性示例
    .局部变量 可读性, 逻辑型
    .局部变量 窗口序号, 整数型
    .局部变量 测试地址, 长整数型
    
    窗口序号 = 0
    
    ' 测试多个地址的可读性
    .局部变量 地址列表, 长整数型, , "0"
    重定义数组 (地址列表, 假, 5)
    地址列表 [1] = 4194304      ' 0x400000
    地址列表 [2] = 8388608      ' 0x800000  
    地址列表 [3] = 0            ' NULL地址
    地址列表 [4] = 4294967295   ' 0xFFFFFFFF
    地址列表 [5] = 16777216     ' 0x1000000
    
    .局部变量 i, 整数型
    .计次循环首 (5, i)
        测试地址 = 地址列表 [i]
        可读性 = HD内存_地址是否可读 (窗口序号, 测试地址)
        
        .如果 (可读性 = 真)
            调试输出 ("地址0x" + 到十六进制 (测试地址) + "可读")
        .否则
            调试输出 ("地址0x" + 到十六进制 (测试地址) + "不可读")
        .如果结束
    .计次循环尾 ()
```
### HCM_IsBadReadAddr - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCM_IsBadReadAddr - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCM_AsmCallX86
### 描述
```
执行汇编CALLX86传递汇编代码
```
### 原型
```
__int64 __stdcall HCM_AsmCallX86(__int32 窗口序号,__int64 excuteCallAddr,char* 汇编文本A=NULL,BOOL bFreeAddr=FALSE,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int64 excuteCallAddr - 目标进程地址
char* 汇编文本A - 汇编文本汇编文本不宜过大内部转换为汇编最大2048字节
 如果汇编转换机器码错误,则json格式 - \"{\\"error\\"
bool bFreeAddr - 是否释放地址指定excuteCallAddr参数仅仅只是释放内存不会执行汇编
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
返回执行汇编CALL的返回值或错误值
当执行汇编流程会返回这个json格式:XXXX|YYYYY===执行内存地址|汇编执行返回值
当汇编转换错误会返回这个json格式:\"{\\"error\\":0,\\"ret\\":[{\\"bRet\\":%d,\\"outSize\\":%d,\\"count\\":%d,\\"error\\":%d}]}\"
```
### 注意事项
```
无
```
### HCM_AsmCallX86 - 基础示例
```
.版本 2

.子程序 _执行汇编X86示例
    .局部变量 执行结果, 长整数型
    .局部变量 窗口序号, 整数型
    .局部变量 汇编代码, 文本型
    
    窗口序号 = 0
    汇编代码 = "mov eax,0x12345678\nret"  ' 简单的汇编指令
    
    执行结果 = HD内存_执行汇编X86 (窗口序号, 汇编代码, 0)
    
    .如果 (执行结果 ≠ 0)
        调试输出 ("汇编代码执行成功，返回值: 0x" + 到十六进制 (执行结果))
    .否则
        调试输出 ("汇编代码执行失败")
    .如果结束
    
    ' 注意：执行汇编代码需要谨慎，可能影响目标进程稳定性
```
### HCM_AsmCallX86 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCM_AsmCallX86 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
## 📌 函数: HCM_AsmCallX64
### 描述
```
执行汇编CALLX64传递汇编代码
```
### 原型
```
__int64 __stdcall HCM_AsmCallX64(__int32 窗口序号,__int64 excuteCallAddr,char* 汇编文本A=NULL,BOOL bFreeAddr=FALSE,BOOL 是否主线程调用=FALSE);
```
### 参数
```
__int32 窗口序号 - 窗口序号(从1开始)
__int64 excuteCallAddr - 目标进程地址
char* 汇编文本A - 汇编文本汇编文本不宜过大内部转换为汇编最大2048字节
 如果汇编转换机器码错误,则json格式 - \"{\\"error\\"
bool bFreeAddr - 是否释放地址指定excuteCallAddr参数仅仅只是释放内存不会执行汇编
bool 是否主线程调用 - 是否主线程调用
```
### 返回值
```
查看返回值表
返回执行汇编CALL的返回值或错误值
当执行汇编流程会返回这个json格式:XXXX|YYYYY===执行内存地址|汇编执行返回值
当汇编转换错误会返回这个json格式:\"{\\"error\\":0,\\"ret\\":[{\\"bRet\\":%d,\\"outSize\\":%d,\\"count\\":%d,\\"error\\":%d}]}\"
```
### 注意事项
```
无
```
### HCM_AsmCallX64 - 基础示例
```
.版本 2

.子程序 _执行汇编X64示例
    .局部变量 执行结果, 长整数型
    .局部变量 窗口序号, 整数型
    .局部变量 汇编代码, 文本型
    
    窗口序号 = 0
    汇编代码 = "mov rax,0x123456789ABCDEF0\nret"  ' 64位汇编指令
    
    执行结果 = HD内存_执行汇编X64 (窗口序号, 汇编代码, 0)
    
    .如果 (执行结果 ≠ 0)
        调试输出 ("64位汇编执行成功，返回值: 0x" + 到十六进制 (执行结果))
    .否则
        调试输出 ("64位汇编执行失败")
    .如果结束
```
### HCM_AsmCallX64 - 进阶用法
```
.版本 2
.子程序 示例2
    调试输出("示例2")
```
### HCM_AsmCallX64 - 高级应用
```
.版本 2
.子程序 高级示例
    调试输出("高级示例")
```

---
